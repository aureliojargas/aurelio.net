Sed HOWTO
Versão 0.6 - junho/2009
Aurelio Marinho Jargas


------------------------------------------------------------------------


  1. Sobre este documento
    1.1. Descrição
    1.2. Anúncio
    1.3. Onde encontrá-lo
    1.4. Registro de mudanças
    1.5. Agradecimentos
  2. Conhecendo o sed
    2.1. Descrição do Sed
    2.2. O que significa a palavra Sed
    2.3. Como saber se devo usar o Sed
      2.3.1. Quando usar o Sed
      2.3.2. Quando não usar o Sed
        2.3.2.1. Edição genérica de textos
        2.3.2.2. Programação avançada
  3. Perdendo o medo do sed
    3.1. Como ele funciona
    3.2. Sua sintaxe
      3.2.1. Exemplo
      3.2.2. Outros exemplos
    3.3. Como executá-lo
  4. Os comandos do sed
    4.1. Descrição de todos os comandos
    4.2. Lista de todos os comandos por categoria
  5. Conceitos básicos
    5.1. Suprimindo a saída padrão
      5.1.1. Saída normal
      5.1.2. Saída suprimida
    5.2. O endereço
      5.2.1. Endereço simples
      5.2.2. Intervalo
      5.2.3. Outros
    5.3. Interrompendo o processamento
    5.4. Invertendo a lógica
    5.5. Aplicando vários comandos de uma vez
      5.5.1. Comandos normais
      5.5.2. Comandos com parâmetros
      5.5.3. Terceira via
  6. Conceitos complementares
    6.1. Sed e shell
    6.2. Usando outros delimitadores
      6.2.1. No comando s
      6.2.2. No endereço
    6.3. Escapes para caracteres especiais
    6.4. Gravando o resultado no mesmo arquivo
      6.4.1. Problema inicial
      6.4.2. Solução genérica
      6.4.3. Solução segura
  7. Tarefas diversas
    7.1. Como substituir alguma coisa por uma quebra de linha
    7.2. Apagando linhas específicas
    7.3. Como ignorar maiúsculas e minúsculas
    7.4. Lendo e gravando em arquivos externos
      7.4.1. Lendo arquivos
      7.4.2. Gravando arquivos
    7.5. Trocando um trecho de texto por outro
      7.5.1. Trocar várias linhas por uma
      7.5.2. Trocar várias linhas por outras
    7.6. Emulando outros comandos
  8. Conceitos avançados
    8.1. Monitorando um arquivo
    8.2. Colocando comandos Sed num arquivo
    8.3. Tornando arquivos Sed executáveis
    8.4. Conhecendo os registradores internos
      8.4.1. Apresentação
      8.4.2. Exemplo
      8.4.3. Exemplo gráfico
      8.4.4. Resumão
      8.4.5. Fluxograma
  9. Fluxogramas
    9.1. Fluxos do texto
    9.2. Fluxos da execução dos comandos
    9.3. Fluxos dos registradores internos
  10. Nota sobre os adicionais GNU
  11. Onde obter mais informações


------------------------------------------------------------------------


  1. Sobre este documento
  =======================


	1.1. Descrição
	==============

Este documento se propõe a ser um tutorial e um guia de consulta de
Sed ao mesmo tempo.

- Tutorial porque ele vai lhe apresentando o Sed aos poucos, explicando
  seu funcionamento.
- Guia de consulta porque ele tem dicas avançadas e descreve truques
  específicos que só serão assimilados e compreendidos executando-os na
  prática.

Este documento NÃO abordará as Expressões Regulares (http://aurelio.net/er),
que são um tema complexo, e embora façam parte da essência do Sed,
seu funcionamento independe delas.

Resumindo, o Sed HOWTO fala sobre Sed.

Este documento pode (deve) ser distribuído à vontade.


	1.2. Anúncio
	============

Este documento é algo que eu estava me devendo há séculos: uma
documentação decente em português sobre o Sed e seus detalhes.

É o Sed HOWTO, um misto de tutorial e guia de referência, com
exemplos práticos. A idéia é que sirva tanto aos principiantes
quanto aos iniciados, abrangendo conceitos básicos e complexos.

http://aurelio.net/sed/sed-HOWTO

Convido todos a visitarem e dar uma lida.

Além da versão html, o documento está disponível em texto, sgml e pdf.
O sgml ainda pode ser convertido em info, dvi, tex, lyx, rtf e xml.

Além de uma explicação bem detalhada, "gráfica" e didática dos
registradores internos e seus comandos

Com certeza, ainda tem MUITA coisa a melhorar/acrescentar.
Qualquer sugestão é bem-vinda.


	1.3. Onde encontrá-lo
	=====================

A casa oficial deste documento é na seção Sed do Site do Aurelio.
Você pode consultá-lo on-line ou baixá-lo para leitura local em
quaisquer dos formatos seguintes:

   || formato  |              endereço                 |   detalhe
   |   online  | http://aurelio.net/sed/sed-HOWTO/     | várias páginas
   | impressão | http://aurelio.net/sed/sed-HOWTO.html | tudo-em-um
   |      txt  | http://aurelio.net/sed/sed-HOWTO.txt  | versão texto


	1.4. Registro de mudanças
	=========================

2009-06-26 — v0.6
  - Documento convertido para UTF-8
  - A versão HTML de uma única página agora vem sem formatação (CSS)
    para facilitar a impressão
  - Removidas as versões PDF e SGML deste documento, para facilitar
    sua manutenção
  - Todos os links externos foram verificados e atualizados
  - Agora as referências internas para outros tópicos são links
  - Padronizado o nome "Sed" em vez de "sed" e "SED" ao referir-se ao programa
  - Adicionado link e melhorada a tabela em Emulando outros comandos
  - Melhorias nos desenhos ASCII (curvas com + e alinhamento)
  - Melhorias de formatação na lista de agradecimentos

2003-04-15 — v0.5
  - Listagem dos comandos adicionada em Descrição de todos os comandos
  - Mudanças cosméticas, URLs atualizadas, s/endereçamento/endereço/g
  - Adicionada versão HTML (tudo em uma página) e retirada a versão em
    PostScript (basta fazer sgml2latex -o ps sed-HOWTO.sgml)
  - Retirado também o .tgz do ar
  - O txt2tags (http://txt2tags.sf.net) agora é o conversor utilizado
    para gerar o Sed HOWTO - acabaram os títulos em CAPSLOCK

2001-02-02 — v0.4
  - Documento disponibilizado agora também em ps e pdf
  - Mais info na seção Anúncio, sobre os formatos novos

2000-12-03 — v0.3
  - Criada seção Trocando um trecho de texto por outro
  - Criada seção Fluxos da execução dos comandos
  - Criada seção Onde encontrá-lo
  - Exemplo gráfico didático em Conhecendo os registradores internos
  - Informações mais didáticas na seção Como ele funciona
  - Documento disponibilizado em txt e sgml
  - Várias correções pequenas nos textos

2000-09-13 — v0.2
  - Criada seção Anúncio
  - Criada seção Registro de mudanças
  - Criada seção Agradecimentos
  - Disponibilizado este documento em HTML compactado
  - Retirada entrada duplicada na seção Emulando outros comandos

2000-08-2 — v0.1
  - 1ª versão
  - Disponibilização na internet


	1.5. Agradecimentos
	===================

Meus agradecimentos sinceros àqueles que comentaram, enviaram sugestões e
correções, ou ajudaram na divulgação, via e-mail ou internet.

- .*@conectiva
- .*@lista_sed-br
- .*@lista_sed-users
- Carlos Alvsan
- Eduardo Mendes
- Rafael Steil
- Rodrigo Bernardo Pimentel
- Rubens Queiroz de Almeida & Dicas-l
- Sérgio Bruder & .BR
- Thobias Salazar Trevisan
- Tiago Barros & senha.org


  2. Conhecendo o sed
  ===================

Vamos conhecer um pouco o Sed, mostrar que ele não é o bicho de
Sed cabeças que aparenta :)


	2.1. Descrição do Sed
	===========================

O Sed é um editor de textos não interativo.

Ele pode editar automaticamente, sem interação do usuário, vários arquivos
seguindo um conjunto de regras especificadas.


	2.2. O que significa a palavra Sed
	========================================

Vem do inglês "Stream EDitor", ou seja, editor de fluxos (de texto).


	2.3. Como saber se devo usar o Sed
	========================================

Sendo um editor de textos não interativo, o Sed é excelente para
desempenhar algumas tarefas, mas em outras seu uso não é aconselhado.


		2.3.1. Quando usar o Sed
		==============================

A característica principal do Sed é poder editar arquivos automaticamente.

Então sempre que você precisar fazer alterações sistemáticas em vários
arquivos, o Sed é uma solução eficaz.

Por exemplo, você tem um diretório cheio de relatórios de vendas, e
descobriu que por um erro na geração, todas as datas saíram erradas, com o
ano de 1999 onde era para ser 2000. Num editor de textos normal, você tem
que abrir os relatórios um por um e alterar o ano em todas as ocorrências.

Certo, isso não é tão complexo se o editor de textos possuir uma ferramenta
de procura e troca, também chamado de substituição.

Mas então suponhamos que o erro da data não seja o ano, e sim o formato,
tendo saído como mm/dd/aaaa quando deveria ser dd/mm/aaaa. Aqui não é
uma substituição e sim uma troca de lugares, e uma ferramenta simples de
procura e troca não poderá ajudar.

Esse é um caso típico onde o Sed mostra seu poder: alterações complexas em
vários arquivos.

Utilizando o Sed, a solução para este problema (que veremos adiante) é até
simples, bastando definir uma série de regras de procura e troca, e o
programa se encarregará de executá-las e arrumar os relatórios.


		2.3.2. Quando não usar o Sed
		==================================

Nenhuma ferramenta é ideal para todas as tarefas, e o Sed não é uma
exceção à regra.


			2.3.2.1. Edição genérica de textos
			==================================

Ele não é prático para ser utilizado como editor de textos de uso genérico.

Para escrever textos, ou alterar coisas simples, é mais rápido e fácil
abrir um editor de textos interativo como o vi ou o emacs e fazer a
alteração "na mão".


			2.3.2.2. Programação avançada
			=============================

O Sed não é uma linguagem de programação completa, pois não possui
variáveis, funções matemáticas, interação com o sistema operacional, entre
outras limitações. Mas bem, ele é um manipulador de texto e não uma
linguagem de uso geral.

Algumas estruturas complexas podem ser simuladas com alguma técnica, mas se
o seu programa em Sed começou a inchar muito, é aconselhável reescrevê-lo
numa linguagem com mais recursos, como o perl.


  3. Perdendo o medo do sed
  =========================


	3.1. Como ele funciona
	======================

O Sed funciona como um filtro, por onde você passa um texto X e ele joga
na saída um texto Y.

O texto X virou Y seguindo algumas regrinhas que você determinou.

Pense no Sed como um processador de alimentos, dependendo da lâmina
utilizada, a batata sai cortada de uma maneira diferente :)

- o Sed funciona como um filtro, ou conversor.

- o Sed é orientado a linha, de cima para baixo, da esquerda para a direita.

- o Sed lê uma linha da entrada padrão (STDIN) ou de um arquivo especificado,
  aplica os comandos de edição e mostra o resultado na saída padrão (STDOUT).
  vai para a próxima linha e repete o processo.

- o Sed aceita endereços para os comandos.

- o Sed aplica os comandos para todas as linhas caso um endereço não
  seja especificado.

- o Sed faz uso intensivo de expressões regulares.

- o Sed é macho :)


	3.2. Sua sintaxe
	================

A sintaxe genérica de um comando Sed é:

  sed [opções] regras [arquivo]

Sendo que regras tem a forma genérica de:

  [endereço1 [, endereço2]] comando [argumento]


		3.2.1. Exemplo
		==============

Como notação tradicional, o que está [entre colchetes] é opcional, então a
sintaxe Sed mais simples que existe é sed regra como em:

  prompt$ cat texto.txt | sed p

Ou seja, o Sed lendo da entrada padrão o conteúdo do arquivo texto.txt
via duto |, aplica o comando p para todas as linhas do arquivo, ou seja,
as duplica.


		3.2.2. Outros exemplos
		======================

Um outro exemplo do Sed com opções e recebendo um arquivo como parâmetro
seria:

  prompt$ sed -n p texto.txt

E ainda, agora especificando um endereço para o comando p:

  prompt$ sed -n 5p texto.txt

Ou seja, este comando imprime apenas a linha 5 do texto.txt


	3.3. Como executá-lo
	====================

A execução do Sed é igual a de outro aplicativo qualquer de manipulação de
texto, aceitando como parâmetro um nome de arquivo, ou na falta deste, lê o
texto da entrada padrão, via duto | ou redirecionamento <.

E como dica geral SEMPRE coloque os comandos do Sed entre aspas simples '',
para evitar que o shell os interprete erroneamente. Veja mais detalhes no
tópico Sed e shell.

  prompt$ sed 'p' texto.txt
  prompt$ cat texto.txt | sed 'p'
  prompt$ sed 'p' < texto.txt

Com outra opção ainda, pode-se executar diretamente um arquivo com comandos
Sed. Para mais informações, veja o tópico Tornando arquivos Sed executáveis.


  4. Os comandos do sed
  =====================


	4.1. Descrição de todos os comandos
	===================================

  prompt$ man sed
  prompt$ pinfo sed

Ou num resumo rápido:

  Legenda:
  
  [ARQUIVO]       arquivo ou fluxo de texto (via pipe) original a ser modificado
  [TEXTO]         trecho de texto. pode ser uma palavra, uma linha,
                  várias separadas por \n, ou mesmo um vazio.
  [PADRÃO]        [TEXTO] contido no ESPAÇO PADRÃO
  
  
  =	imprime o número da linha atual do [ARQUIVO]
  #	inicia um comentário
  !	inverte a lógica do comando
  ;	separador de comandos
  ,	separador de faixas de endereço
  {	início de bloco de comandos
  }	fim de bloco de comandos
  
  s	substitui um trecho de texto por outro
  y	traduz um caractere por outro
  
  i	insere um texto antes da linha atual 
  c	troca a linha atual por um texto
  a	anexa um texto após a linha atual
  
  g	restaura o [TEXTO] contido no ESPAÇO RESERVA (sobrescrevendo)
  G	restaura o [TEXTO] contido no ESPAÇO RESERVA (anexando)
  h	guarda o [PADRÃO] no ESPAÇO RESERVA (sobrescrevendo)
  H	guarda o [PADRÃO] no ESPAÇO RESERVA (anexando)
  x	troca os conteúdos dos ESPAÇO PADRÃO e RESERVA
  
  p	imprime o [PADRÃO]
  P	imprime a primeira linha do [PADRÃO]
  l	imprime o [PADRÃO] mostrando caracteres brancos
  
  r	inclui conteúdo de um arquivo antes da linha atual
  w	grava o [PADRÃO] num arquivo
  
  :	define uma marcação
  b	pula até uma marcação 
  t	pula até uma marcação, se o último s/// funcionou (condicional)
  
  d	apaga o [PADRÃO]
  D	apaga a primeira linha do [PADRÃO]
  n	vai para a próxima linha
  N	anexa a próxima linha no [PADRÃO]
  q	finaliza o Sed imediatamente
  


	4.2. Lista de todos os comandos por categoria
	=============================================

                     informações =
                      marcadores :
                     comentários #
              comandos de edição s i c a y
       comandos de registradores g G h H x
           comandos de impressão p P l
             comandos de arquivo r w
                   modificadores g i !
                     separadores ; -e \n
               controle de fluxo b t d D n N q
                        endereço // ,
                     limitadores {} \(\)
         registradores dinâmicos \1 \2 ... \9


  5. Conceitos básicos
  ====================

Aqui vão conhecimentos que você precisa assimilar para fazer um bom uso do
Sed.


	5.1. Suprimindo a saída padrão
	==============================


		5.1.1. Saída normal
		===================

Normalmente o Sed sempre imprime na saída padrão todas as linhas do
arquivo, modificadas ou não.

Veja o primeiro exemplo citado:

  prompt$ sed 'p' texto.txt

O comando p imprime a linha na saída padrão. Este exemplo duplica todas
as linhas do arquivo pois, além da impressão normal de cada linha, ainda é
aplicado o comando p em cada uma, que diz "imprima esta linha", fazendo
com que ela apareça duas vezes.


		5.1.2. Saída suprimida
		======================

Temos como modificar este comportamento com a opção -n, que significa
"não imprima na saída, a não ser quando especificado com o comando p ou o
l".

Assim sendo, colocando o -n, eliminamos o comportamento padrão de
"imprimir sempre na saída":

  prompt$ sed -n 'p' texto.txt

Que resulta no conteúdo do arquivo, pois cada linha é impressa apenas uma
vez, devido ao comando p. Assim fica fácil entender como funciona o
exemplo já citado que imprime apenas a linha 5 de um arquivo:

  prompt$ sed -n 5p texto.txt

Ok, a explicação daquele 5 ali perdido vem logo a seguir no tópico
O endereço :)


	5.2. O endereço
	===============

O endereço serve para você dizer ao Sed para aplicar um determinado
comando apenas nas linhas informadas. Este endereço pode ser descrito
direto como o número da linha, ou por parte de seu conteúdo (entre
/barras/).

Caso o endereço não seja informado, o comando Sed será aplicado para
todas as linhas.


		5.2.1. Endereço simples
		=======================

Por exemplo, referenciando a linha pelo seu número, como já foi visto
anteriormente:

  prompt$ sed '5d' texto.txt

Mas também poderia ser uma linha que tivesse uma palavra qualquer:

  prompt$ sed '/estorvo/d' texto.txt

O comando d apaga linhas segundo o endereço, então este comando
apagará todas as linhas que tiverem a palavra estorvo. Este exemplo tem o
funcionamento idêntico ao comando:

  prompt$ grep -v estorvo texto.txt


		5.2.2. Intervalo
		================

Como endereço, ainda se pode especificar um intervalo, como da linha
5 até a linha 10, ou da linha 5 até a linha que tiver a palavra estorvo:

  prompt$ sed '5,10d' texto.txt
  prompt$ sed '5,/estorvo/d' texto.txt

No endereço, temos um caractere especial, o $ que referencia à
última linha do texto. Assim sendo, para apagar da linha 10 até o
final do texto, o comando é:

  prompt$ sed '10,$d' texto.txt


		5.2.3. Outros
		=============

No Sed da GNU, a partir da versão 3.02a(*), foi adicionada uma maneira
nova de especificar um endereço:

  prompt$ sed '/estorvo/,+3d' texto.txt

Que referencia a linha que contém a palavra estorvo e mais as 3 linhas
seguintes.

E pra finalizar, como já dito anteriormente, quando o comando não tem
endereço, é aplicado para todas as linhas:

  prompt$ sed 'd' texto.txt

(*) veja o tópico Nota sobre os adicionais GNU


	5.3. Interrompendo o processamento
	==================================

A qualquer hora você pode abortar o comando Sed com o comando q.

Isso é útil no nosso exemplo anterior de emular o comando head,
imprimindo apenas as 10 primeiras linhas do arquivo:

  sed '10q'         ao chegar na linha 10, pare.

Ou ainda, para obter apenas os cabeçalhos de uma mensagem de e-mail, que
são separados do corpo da mensagem por uma linha em branco:

  sed '/^$/q'       pare na primeira linha em branco que achar


	5.4. Invertendo a lógica
	========================

No Sed temos o modificador ! que inverte a lógica do comando, ou seja
!comando significa "não execute o comando". É meio estranho a primeira
vista, mas você tem que começar a pensar como o Sed, e tudo se esclarece
:)

Temos o comando head que imprime as 10 primeiras linhas de um arquivo.
Com as dicas já vistas, podemos fazer esta tarefa com o Sed assim:

  sed -n '1,10p'    imprima apenas da linha 1 até a 10
  sed '11,$d'       apague da linha 11 até o final

Ou ainda, podemos inverter a lógica e fazer:

  sed '1,10!d'      NÃO apague da linha 1 até a 10 (ou seja, apague as outras)
  sed -n '11,$!p'   NÃO imprima da linha 11 até o final (ou seja, imprima as outras)

A dica é sempre complementar a leitura mental com o inverso (entre
parênteses nos exemplos), ou seja, se o Sed NÃO vai aplicar um comando em
determinadas linhas, isso quer dizer implicitamente que este comando
será aplicado em todas as outras linhas. É estranho, mas acostuma :)


	5.5. Aplicando vários comandos de uma vez
	=========================================


		5.5.1. Comandos normais
		=======================

É possível aplicar vários comandos Sed, em seqüência. Basta
separá-los por ponto-e-vírgula.

  prompt$ sed '5d;10d;/estorvo/d' texto.txt

Este comando apaga as linhas 5, 10 e as que têm estorvo do arquivo
texto.txt.


		5.5.2. Comandos com parâmetros
		==============================

Os comandos que recebem parâmetros (r, w, i, a, c), não aceitam
o ponto-e-vírgula como separador, pois este pode ser parte integrante do
parâmetro esperado.

Estes comandos devem ser separados dos restantes, sendo passados como
comandos isolados, pela opção de linha de comando -e:

  prompt$ sed -e '1i começo de tudo' -e '5d' texto.txt

Este comando insere a frase começo de tudo antes da primeira linha e
apaga a quinta linha do arquivo texto.txt.


		5.5.3. Terceira via
		===================

Outra maneira de especificar vários comandos (e a mais consistente e
garantida) é colocá-los num arquivo, um por linha. Veja o tópico
Colocando comandos Sed num arquivo.


  6. Conceitos complementares
  ===========================

Estes são conhecimentos que possivelmente surgirão como dúvidas em sua
cabeça após utilizar o Sed por um tempo.


	6.1. Sed e shell
	================

Com o Sed sendo invocado na linha de comando, deve-se ter alguns cuidados
para evitar transtornos. O interpretador de comandos (shell), interpreta a
linha de comando antes de processá-la, então alguns caracteres especiais
como $, \ e !, são interpretados pelo shell antes de chegarem ao
Sed, modificando o comportamento esperado.

Para evitar isso coloque os comandos Sed sempre entre aspas simples:

  prompt$ sed 's/isso/aquilo/' texto.txt

Salvo quando no meio do comando Sed, existir algo que deva ser
interpretado, como uma variável por exemplo. Neste caso coloque os comandos
entre aspas duplas:

  prompt$ sed "s/$HOME/aquilo/" texto.txt

Ou ainda, para evitar completamente a interpretação do shell, sem se
preocupar com aspas, coloque os comandos Sed num arquivo. Veja o tópico
Colocando comandos Sed num arquivo.


	6.2. Usando outros delimitadores
	================================


		6.2.1. No comando s
		===================

É comum ao fazer um comando de substituição s/// conter uma
/ num dos dois lados do comando, como quando querendo substituir
/usr/local/bin por /usr/bin.

Sendo a barra o delimitador do comando s as outras barras comuns devem
ser escapadas com a barra invertida \, para não serem confundidas com os
delimitadores normais, ficando o monstro a seguir:

  prompt$ sed 's/\/usr\/local\/bin/\/usr\/bin/' texto.txt

Para evitar ter que ficar se escapando todas estas barras, basta lembrar
que o comando s aceita qualquer delimitador, sendo a barra apenas um
padrão de referências históricas. Então, neste caso, poderíamos escolher
outro delimitador como por exemplo a vírgula:

  prompt$ sed 's,/usr/local/bin,/usr/bin,' texto.txt

Evitando-se de ter que ficar escapando as barras. A mesma dica vale para o
comando y.


		6.2.2. No endereço
		==================

E se precisássemos apagar as linhas que contém o /usr/local/bin? Teríamos
que colocar o nome do diretório no endereço do comando d, voltando
com a festa dos escapes:

  prompt$ sed '/\/usr\/local\/bin/d' texto.txt

Para usarmos outro delimitador no endereço, basta escaparmos o
primeiro, que no caso abaixo é a vírgula:

  prompt$ sed '\,/usr/local/bin,d' texto.txt

Confusão de delimitadores com o texto a ser procurado é muito comum de
acontecer, então se algo não está funcionando como deveria, olhe com
cuidado para ver se não há conflitos entre eles.


	6.3. Escapes para caracteres especiais
	======================================

No Sed da GNU, a partir da versão 3.02.80(*), vários escapes novos
foram adicionados e podem ser usados nas duas partes do comando s///:

     \a      beep             (apito)
     \f      form-feed        (avança linha)
     \n      newline          (quebra de linha)
     \r      carriage-return  (retorno de carro)
     \t      hTAB             (tabulação horizontal)
     \v      vTAB             (tabulação vertical)
     \oNNN   o caractere de valor octal NNN
     \dNNN   o caractere de valor decimal NNN
     \xNN    o caractere de valor hexadecimal NN

(*) veja o tópico Nota sobre os adicionais GNU


	6.4. Gravando o resultado no mesmo arquivo
	==========================================


		6.4.1. Problema inicial
		=======================

O procedimento comum quando se quer gravar num arquivo o resultado de um
comando Sed, é o redirecionamento:

  prompt$ sed 'comando' texto.txt > texto-alterado.txt

Mas é muito comum, ao alterarmos um arquivo, queremos gravar estas
alterações no próprio arquivo original. A tentativa intuitiva seria:

  prompt$ sed 'comando' texto.txt > texto.txt

Mas é só fazer para ver. Além de não dar certo, você ainda perderá todo o
conteúdo do arquivo.

Isso acontece porque ao fazer o redirecionamento >, o shell abre
imediatamente o arquivo referenciado, antes mesmo de começar a executar o
comando Sed. E como este é um redirecionamento destrutivo > e não
incremental >>, se o arquivo já existir, ele será truncado, e seu
conteúdo perdido. A essa altura, o Sed começará seu processamento já
lendo um arquivo texto.txt vazio, e aplicados qualquer comandos
Sed num
arquivo vazio, o resultado será o próprio arquivo vazio.


		6.4.2. Solução genérica
		=======================

Para evitar isso, voltamos a primeira tática de gravar o resultado num
outro arquivo, e depois o mais natural é mover o arquivo novo sobre o
original:

  prompt$ sed 'comando' texto.txt > texto-alterado.txt
  prompt$ mv texto-alterado.txt texto.txt

Para a grande maioria dos casos, isso é suficiente, mas convém aqui lembrar
que caso o arquivo 'texto.txt' possua atributos especiais, grupo diferente
do padrão do usuário, ou referências (links, simbólicos ou não) para outros
arquivos, tudo isso será perdido. Ao mover o arquivo recém-criado, com os
atributos padrão do sistema, sobre o original, este perderá seus atributos
e ficará com os padrões do sistema, herdado do arquivo novo.


		6.4.3. Solução segura
		=====================

Para evitar isso, a abordagem mais ortodoxa e segura seria aplicar o
comando Sed numa cópia e gravar o resultado no arquivo original via
redirecionamento:

  prompt$ cp -a texto.txt texto-tmp.txt
  prompt$ sed 'comando' texto-tmp.txt > texto.txt
  prompt$ rm texto-tmp.txt

Novamente, isso só é necessário com arquivos especiais, senão a solução com
o mv pode ser usada. Mas é importante ter em mente esta outra maneira e
principalmente saber o porque de utilizá-la, sendo este conhecimento
aplicável a qualquer outro comando do sistema que leia e grave arquivos.


  7. Tarefas diversas
  ===================


	7.1. Como substituir alguma coisa por uma quebra de linha
	=========================================================

No Sed da GNU, a partir da versão 3.02.80(*), foi adicionado o \n
como escape válido dos dois lados do comando s///. Com isso a tarefa de
colocar cada palavra numa linha isolada, ou seja, trocar espaços em branco
por quebras de linha, fica trivial:

  prompt$ sed 's/ /\n/g' texto.txt

Mas com outras versões do Sed que não entendem este escape, a quebra de
linha deve ser inserida literalmente e deve ser escapada:

  prompt$ sed 's/ /\
  prompt$ /g' texto.txt

Como curiosidade, a operação inversa, de colocar todas as linhas de um
arquivo numa linha só, já é mais trabalhosa e utiliza o conceito de laço:

  prompt$ sed ':a;$!N;s/\n/ /g;ta'

(*) veja o tópico Nota sobre os adicionais GNU


	7.2. Apagando linhas específicas
	================================

O comando para apagar linhas é o d.

O único detalhe nesta tarefa é especificar quais linhas você vai querer
apagar. Isso está  completamente coberto no tópico O endereço.


	7.3. Como ignorar maiúsculas e minúsculas
	=========================================

O jeito padrão do Sed ser "ignore-case", é dizendo literalmente todas as
possibilidades, como em:

  prompt$ sed '/[Rr][Oo][Oo][Tt]/d' texto.txt

Para apagar todas as linhas que contêm a palavra root, ROOT, RooT
etc.

No Sed da GNU, a partir da versão 3.01-beta1(*), foi adicionado o
modificador I no endereço e no comando s///, fazendo com que o
comando acima fique mais simples:

  prompt$ sed '/root/Id' texto.txt

Ou ainda:

  prompt$ sed 's/root/administrador/Ig' texto.txt

(*) veja o tópico Nota sobre os adicionais GNU


	7.4. Lendo e gravando em arquivos externos
	==========================================


		7.4.1. Lendo arquivos
		=====================

Uma tarefa comum é incluir cabeçalho e rodapé num arquivo qualquer. O
Sed possui um comando específico para ler arquivos, o r, então
basta(*):

  prompt$ sed -e '1r cabecalho.txt' -e '$r rodape.txt' texto.txt

Para incluir o cabeçalho após a linha 1 e incluir o rodapé após a
última linha.

(*) a explicação do porquê das opções -e está no tópico
Aplicando vários comandos de uma vez.


		7.4.2. Gravando arquivos
		========================

O comando w grava num arquivo a linha atual, ou melhor, o conteúdo do
espaço padrão. Por exemplo, você quer gravar num arquivo o resultado de
uma busca por linhas que contêm a palavra estorvo. A solução não-Sed
seria:

  prompt$ grep 'estorvo' texto.txt > estorvos.txt

Nosso similar em Sed seria:

  prompt$ sed '/estorvo/w estorvos.txt' texto.txt

Gravar dados num arquivo também pode servir de espaço auxiliar caso o
espaço reserva não seja suficiente. Mas esta é uma opção drástica, não
tão flexível. Mais informações sobre o espaço reserva no tópico
Conhecendo os registradores internos.


	7.5. Trocando um trecho de texto por outro
	==========================================

Uma tarefa que parece simples mas confunde, é trocar um trecho de texto,
como um parágrafo inteiro por exemplo, por outro trecho, independente do
número de linhas de ambos.


		7.5.1. Trocar várias linhas por uma
		===================================

Essa é simples, basta usar o comando c, que "Coloca" um texto no lugar da
linha atual. A única complicação é definir o endereço, para aplicar
o comando apenas nas linhas desejadas. Por exemplo, vamos colocar uma frase
no lugar de uma área de texto pré-formatado num documento HTML. Esta área é
delimitada pelos identificadores <pre> e </pre>:

  prompt$ sed '/<pre>/,/<\/pre>/c \
  prompt$ aqui tinha texto pré-formatado' texto.html

Note que o comando c (assim como o a e o i) exige que o texto que
ele recebe como parâmetro esteja na linha seguinte, estando a quebra de
linha escapada com a barra invertida \

No Sed da GNU, a partir da versão 3.02a(*), é permitido que se coloque
o texto na mesma linha:

  prompt$ sed '/<pre>/,/<\/pre>/c aqui tinha texto pré-formatado' texto.html

(*) veja o tópico Nota sobre os adicionais GNU


		7.5.2. Trocar várias linhas por outras
		======================================

Similarmente a trocar por apenas uma linha, pode-se usar o comando c e
passar várias linhas para ele. O único detalhe é que todas as linhas devem
ser escapadas no final, menos a última:

  prompt$ sed '/<pre>/,/<\/pre>/c \
  prompt$ aqui tinha texto pré-formatado,\
  prompt$ mas eu resolvi tirar.\
  prompt$ porque?\
  prompt$ porque sim' texto.html

É claro, quando o comando começa a ficar grande desse jeito, é melhor
colocá-lo num arquivo. Saiba mais detalhes sobre isso no tópico
Colocando comandos sed num arquivo.

Mas melhor ainda é separar o comando Sed do texto, colocando-o num
arquivo separado. Assim, quando se precisar alterar este texto, basta
editá-lo, sem mudar o comando Sed, e sem precisar ficar colocando \ no
final de cada linha.

Supondo que nosso texto explicativo do porquê da retirada do texto
pré-formatado foi gravado no arquivo desculpa.txt, utilizaremos o comando
r para lê-lo e o comando d para apagar o texto antigo:

  prompt$ sed -e '/<\/pre>/r desculpa.txt' -e '/<pre>/,/<\/pre>/d' texto.html

Então acompanhe o que acontece: o primeiro comando será executado apenas na
linha </pre> que é o fechamento do trecho, então vamos esquecer dele por
enquanto. O segundo comando diz para apagar o trecho desde <pre> até
</pre>, então assim que começar o trecho, ele vai apagando, linha por
linha.

Ao chegar na linha que contém o </pre>, o primeiro comando Sed entra em
ação e lê o arquivo desculpa.txt, colocando seu conteúdo imediatamente
após a linha atual. Em seguida, o segundo comando apaga a linha </pre>,
completando a tarefa.

Esta segunda solução é mais difícil de entender e implementar, mas é muito
mais prática caso a alteração do texto a ser colocado seja freqüente, além
destas alterações poderem ser feitas por alguém que nem saiba o que é
Sed, pois será apenas um texto normal.

Note que sempre que o </pre> foi referenciado nos endereços, a
barra foi escapada, ficando <\/pre>. A explicação desse escape está em
Usando outros delimitadores

obs.: talvez o <pre></pre> não seja um exemplo dos mais didáticos, mas
não me veio algo mais comum à mente...


	7.6. Emulando outros comandos
	=============================

Aqui vão alguns exemplos de emulações de outros comandos usando-se o
Sed:

   ||   comando   |     emulação  
   | cat          | sed :
   | head         | sed 10q
   | grep         | sed /padrão/!d
   | grep -v      | sed /padrão/d
   | tac          | sed 1!G;h;$!d
   | tail -1      | sed $!d
   | tr A-Z a-z   | sed y/ABCDEF...UVWXYZ/abcdef...uvwxyz/
   | wc -l        | sed -n $=

A lista completa e atualizada pode ser encontrada em:
http://sed.sourceforge.net/local/docs/emulating_unix.txt


  8. Conceitos avançados
  ======================

Estes são conhecimentos necessários àqueles que fazem uso intensivo do
Sed, fazendo programas grandes e/ou complexos.


	8.1. Monitorando um arquivo
	===========================

No Sed da GNU, a partir da versão 3.02.80(*), foi adicionada a opção
-u, que significa "unbuffered", ou seja, faz um uso minimalista dos
registradores, mostrando a saída o mais rápido possível, tornando possível
editar um fluxo interminável como o gerado por um tail -f.

Um exemplo prático seria mostrar apenas as mensagens do sistema relativas
às conexões ssh:

  prompt$ tail -f /var/log/messages | sed -nu '/sshd/p'

Cuidado com -nu perto de crianças! :)

(*) veja o tópico Nota sobre os adicionais GNU


	8.2. Colocando comandos Sed num arquivo
	=======================================

Como os comandos Sed vão ficando extensos e complicados, é conveniente
colocá-los num arquivo, com estruturação e comentários.

Você pode espalhar os comandos por várias linhas, trocando o ; por quebras
de linha e colocar comentários precedidos de #. O exemplo de apagar
linhas ficaria:

  # programa.sed: apaga algumas linhas
  
  # apaga a 5ª linha
  5d
  
  # apaga a 10ª linha
  10d
  
  # apaga as linhas que contêm 'estorvo'
  /estorvo/d

Para dizer ao Sed para utilizar aquele arquivo como fonte de comandos,
basta usar a opção -f

  prompt$ sed -f programa.sed texto.txt


	8.3. Tornando arquivos Sed executáveis
	======================================

O interpretador de comandos mais utilizado (bash) sempre procura na
primeira linha de um arquivo instruções para executá-lo.

Se um arquivo é um programinha em shell, basta colocar

  #!/bin/sh

Na primeira linha para que o bash saiba que deve executá-lo com o
comando /bin/sh. O mesmo funciona para qualquer outro interpretador,
como o Sed. então para tornar um arquivos de comandos Sed
executável basta colocar como primeira linha:

  #!/bin/sed -f

E é claro, torná-lo executável:

  prompt$ chmod +x programa.sed

E na linha de comando, chame-o normalmente:

  prompt$ ./programa.sed texto.txt
  prompt$ cat texto.txt | ./programa.sed


	8.4. Conhecendo os registradores internos
	=========================================


		8.4.1. Apresentação
		===================

O Sed possui 2 registradores ("buffers") internos, que são usados para a
manipulação do texto.

Um deles é o espaço padrão ("pattern space"), que é o registrador
utilizado normalmente pelo Sed. É nele que a linha a ser processada é
armazenada e manipulada.

O outro é o espaço reserva ("hold space"), que é um registrador auxiliar,
inicialmente vazio, que serve para guardar uma cópia da linha original,
parte dela, ou agrupar dados diversos de várias linhas.

Há comandos para fazer a troca de dados entre os dois registradores:

    h      guarda no espaço reserva
    H      guarda (anexando) no espaço reserva
  
    g      pega o conteúdo do espaço reserva
    G      pega (anexando) o conteúdo do espaço reserva
  
    x      troca os conteúdos dos 2 registradores

O anexando acima significa "não sobrescreve o conteúdo original", ou
seja, ele mantém o que já tem, e adiciona um \n (quebra de linha),
seguido do texto manipulado. Para entender melhor, veja o exemplo gráfico
a seguir.


		8.4.2. Exemplo
		==============

Um exemplo didático de uso do espaço reserva é ir guardando nele algumas
linhas do texto e mostrá-las depois no final do arquivo:

  prompt$ sed '/root/H;$g' /etc/passwd

Ou seja, adicione no espaço reserva (comando H), as linhas que contêm a
palavra root e na última linha do arquivo (endereço $), recupere o
conteúdo do espaço reserva (comando g).


		8.4.3. Exemplo gráfico
		======================

Como os registradores são a parte mais obscura do Sed (mais por falta
de documentação do que por complexidade), merecem uma explicação bem
didática. Vamos lá.

Temos os dois registradores vazios:
(que daqui pra frente serão chamados apenas de padrão e reserva)

        __________________                __________________
       |                  |              |                  |
       |                  |              |                  |
       |__________________|              |__________________|
          espaço padrão                     espaço reserva

E um arquivo hipotético com o conteúdo:
(não são odiosos estes exemplos com frutas?)

  laranja
  uva
  abacaxi
  melancia
  mimosa

E aplicaremos o comando:

  sed '/laranja/h ; /uva/g ; /abacaxi/H ; /melancia/G ; /mimosa/x'

Obtendo como resultado:

  laranja
  laranja
  abacaxi
  melancia
  laranja
  abacaxi
  laranja
  abacaxi

Vejamos o que aconteceu. Lida a primeira linha laranja, ela é
imediatamente colocada no padrão para ser manipulada:

        __________________                __________________
       |                  |              |                  |
       |      laranja     |              |                  |
       |__________________|              |__________________|
          espaço padrão                     espaço reserva

O comando direcionado a ela é o h, que guarda uma cópia dela no
reserva:

        __________________                __________________
       |                  |              |                  |
       |      laranja     |   -- h -->   |      laranja     |
       |__________________|              |__________________|
          espaço padrão                     espaço reserva

Como mais nenhum comando é relativo à linha laranja, o Sed dá por
encerrado o processamento dessa linha e imprime o conteúdo do padrão na
saída: "laranja".

Beleza, agora ele vai processar a segunda linha, novamente a primeira coisa
é colocá-la no padrão, sobrescrevendo o que tinha antes:

        __________________                __________________
       |                  |              |                  |
       |        uva       |              |      laranja     |
       |__________________|              |__________________|
          espaço padrão                     espaço reserva

O reserva, enquanto nenhum outro comando escrever nele, permanecerá o
mesmo. O comando direcionado à linha uva é o g, que pega o conteúdo do
reserva e o coloca no padrão, apagando o que estiver nele (neste caso:
uva):

        __________________                __________________
       |                  |              |                  |
       |      laranja     |   <-- g --   |      laranja     |
       |__________________|              |__________________|
          espaço padrão                     espaço reserva

Novamente, não há mais comandos a ser executados, então imprime na saída o
conteúdo do padrão: "laranja".

Indo para a terceira linha e colocando-a no padrão:

        __________________                __________________
       |                  |              |                  |
       |      abacaxi     |              |      laranja     |
       |__________________|              |__________________|
          espaço padrão                     espaço reserva

O comando dessa linha é o H, que tal como o h, guarda o conteúdo do
padrão no reserva, com diferença que ele preserva o conteúdo já
existente dele, separando com um \n:

        __________________                __________________
       |                  |              |                  |
       |      abacaxi     |   -- H -->   | laranja\nabacaxi |
       |__________________|              |__________________|
          espaço padrão                     espaço reserva

Novamente, chegou ao fim, imprime o padrão: "abacaxi".
a próxima linha é a da melancia:

        __________________                __________________
       |                  |              |                  |
       |     melancia     |              | laranja\nabacaxi |
       |__________________|              |__________________|
          espaço padrão                     espaço reserva

E agora vai ficar divertido, aplicando o comando G, que pega o conteúdo
do reserva e anexa ao padrão:

   ____________________________           __________________
  |                            |         |                  |
  | melancia\nlaranja\nabacaxi |  <-G--  | laranja\nabacaxi |
  |____________________________|         |__________________|
          espaço padrão                    espaço reserva

E a saída agora fica "melancia\nlaranja\nabacaxi", com o detalhe que o
Sed troca estes \n por quebras de linha na impressão. Então são 3
linhas na saída. Vá acompanhando com o resultado que já foi cantado
antecipadamente lá em cima.

E finalmente, a última linha:

        __________________                __________________
       |                  |              |                  |
       |      mimosa      |              | laranja\nabacaxi |
       |__________________|              |__________________|
          espaço padrão                     espaço reserva

E para ela, o comando que troca o conteúdo dos 2 registradores, o x:

        __________________                __________________
       |                  |              |                  |
       | laranja\nabacaxi |  <-- x --->  |      mimosa      |
       |__________________|              |__________________|
          espaço padrão                     espaço reserva

E mostra na saída o padrão, com duas linhas: "laranja" e "abacaxi".

Ufa! Depois dessa não venha me dizer que não sabe como funcionam os
registradores internos do Sed ;)


		8.4.4. Resumão
		==============

- Cada linha nova lida é colocada (sobrescrevendo) no espaço padrão
- Uma vez colocado algo no espaço reserva, fica lá até ser sobrescrito
- O \n é o separador do conteúdo original com o anexo
- Na saída, o \n vira quebra de linha
- Registradores são simples! ;)


		8.4.5. Fluxograma
		=================

Para uma representação gráfica dos fluxos e comandos que manipulam estes
registradores, veja o tópico Fluxos dos registradores internos.


  9. Fluxogramas
  ==============


	9.1. Fluxos do texto
	====================

                                    _________
                              w    |         |   r
                          +------->| ARQUIVO |------->
                          |        |_________|
                    ______|______                       SAÍDA
              n    |             |           p P l
  ENTRADA  ------->|    S E D    |------------------->
              N    |_____________|           a i c
                          |
                          |   d
                          +-------> /dev/null
                              D
  


	9.2. Fluxos da execução dos comandos
	====================================

             _________
            |         |
      ______| próxima |<---+
     /      |  linha  |    |
     |      |_________|    |
     |                     |
     v                 d D | n N
                      _____|______
                     |            |
  COMEÇO   --------->|  COMANDOS  |----------> FIM DO PROGRAMA
                     |____________|  q
                       |       ^
                     b | t     |
                       |       |
                       |    ___|______
                       |   |          |
                       +-->| marcação |
                           |__________|
  
  


	9.3. Fluxos dos registradores internos
	======================================

   _________________               __________________
  |                 |---- h H --->|                  |
  |  ESPAÇO PADRÃO  |<---  x  --->|  ESPAÇO RESERVA  |
  |_________________|<--- g G ----|__________________|
  
  

Veja explicação sobre estes registradores no tópico
Conhecendo os registradores internos.


  10. Nota sobre os adicionais GNU
  ================================

O Sed da GNU, atualmente é o utilizado pela maioria das distribuições de
Linux e é o que tem mais funcionalidades novas.

Mas o preço de se usar essas funcionalidades é que se perde em
compatibilidade, pois seu programa Sed não funcionará em UNIXes ou
outros sistemas que usem um Sed que não o da GNU.

Para a grande maioria dos usuários isso não fará diferença pois geralmente
trabalham com apenas um tipo de sistema operacional, mas o recado fica
dado.


  11. Onde obter mais informações
  ===============================

Informações em português:

- http://aurelio.net/sed

Informações em inglês:

- http://sed.sourceforge.net/sed1line.txt
- http://sed.sourceforge.net/sedfaq.html
- http://www.dreamwvr.com/sed-info/sed-faq.html
- http://www.rtfiber.com.tw/~changyj/sed

Última versão em desenvolvimento do Sed:

- ftp://alpha.gnu.org/gnu/sed

