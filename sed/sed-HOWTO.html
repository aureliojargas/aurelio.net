<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<meta name="author" content="Aurelio Marinho Jargas www.aurelio.net">
<META NAME="generator" CONTENT="http://txt2tags.sf.net">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">



<link rel="icon" type="image/png" href="../../img/favhead.png">
<TITLE>Sed HOWTO :: aurelio.net</TITLE>
</HEAD>
<BODY class="sedhowto">

<DIV ID="header">
<H1>Sed HOWTO</H1>
<H2>Versão 0.6 - junho/2009</H2>
<H3><a href="http://aurelio.net">Aurelio Marinho Jargas</a></H3>
</DIV>

<DIV CLASS="toc">

  <OL>
  <LI><A HREF="#toc1">Sobre este documento</A>
    <UL>
    <LI><A HREF="#toc2">1.1. Descrição</A>
    <LI><A HREF="#toc3">1.2. Anúncio</A>
    <LI><A HREF="#toc4">1.3. Onde encontrá-lo</A>
    <LI><A HREF="#toc5">1.4. Registro de mudanças</A>
    <LI><A HREF="#toc6">1.5. Agradecimentos</A>
    </UL>
  <LI><A HREF="#toc7">Conhecendo o sed</A>
    <UL>
    <LI><A HREF="#toc8">2.1. Descrição do Sed</A>
    <LI><A HREF="#toc9">2.2. O que significa a palavra Sed</A>
    <LI><A HREF="#toc10">2.3. Como saber se devo usar o Sed</A>
      <UL>
      <LI><A HREF="#toc11">2.3.1. Quando usar o Sed</A>
      <LI><A HREF="#toc12">2.3.2. Quando não usar o Sed</A>
      </UL>
    </UL>
  <LI><A HREF="#toc13">Perdendo o medo do sed</A>
    <UL>
    <LI><A HREF="#toc14">3.1. Como ele funciona</A>
    <LI><A HREF="#toc15">3.2. Sua sintaxe</A>
      <UL>
      <LI><A HREF="#toc16">3.2.1. Exemplo</A>
      <LI><A HREF="#toc17">3.2.2. Outros exemplos</A>
      </UL>
    <LI><A HREF="#toc18">3.3. Como executá-lo</A>
    </UL>
  <LI><A HREF="#toc19">Os comandos do sed</A>
    <UL>
    <LI><A HREF="#toc20">4.1. Descrição de todos os comandos</A>
    <LI><A HREF="#toc21">4.2. Lista de todos os comandos por categoria</A>
    </UL>
  <LI><A HREF="#toc22">Conceitos básicos</A>
    <UL>
    <LI><A HREF="#toc23">5.1. Suprimindo a saída padrão</A>
      <UL>
      <LI><A HREF="#toc24">5.1.1. Saída normal</A>
      <LI><A HREF="#toc25">5.1.2. Saída suprimida</A>
      </UL>
    <LI><A HREF="#toc26">5.2. O endereço</A>
      <UL>
      <LI><A HREF="#toc27">5.2.1. Endereço simples</A>
      <LI><A HREF="#toc28">5.2.2. Intervalo</A>
      <LI><A HREF="#toc29">5.2.3. Outros</A>
      </UL>
    <LI><A HREF="#toc30">5.3. Interrompendo o processamento</A>
    <LI><A HREF="#toc31">5.4. Invertendo a lógica</A>
    <LI><A HREF="#toc32">5.5. Aplicando vários comandos de uma vez</A>
      <UL>
      <LI><A HREF="#toc33">5.5.1. Comandos normais</A>
      <LI><A HREF="#toc34">5.5.2. Comandos com parâmetros</A>
      <LI><A HREF="#toc35">5.5.3. Terceira via</A>
      </UL>
    </UL>
  <LI><A HREF="#toc36">Conceitos complementares</A>
    <UL>
    <LI><A HREF="#toc37">6.1. Sed e shell</A>
    <LI><A HREF="#toc38">6.2. Usando outros delimitadores</A>
      <UL>
      <LI><A HREF="#toc39">6.2.1. No comando s</A>
      <LI><A HREF="#toc40">6.2.2. No endereço</A>
      </UL>
    <LI><A HREF="#toc41">6.3. Escapes para caracteres especiais</A>
    <LI><A HREF="#toc42">6.4. Gravando o resultado no mesmo arquivo</A>
      <UL>
      <LI><A HREF="#toc43">6.4.1. Problema inicial</A>
      <LI><A HREF="#toc44">6.4.2. Solução genérica</A>
      <LI><A HREF="#toc45">6.4.3. Solução segura</A>
      </UL>
    </UL>
  <LI><A HREF="#toc46">Tarefas diversas</A>
    <UL>
    <LI><A HREF="#toc47">7.1. Como substituir alguma coisa por uma quebra de linha</A>
    <LI><A HREF="#toc48">7.2. Apagando linhas específicas</A>
    <LI><A HREF="#toc49">7.3. Como ignorar maiúsculas e minúsculas</A>
    <LI><A HREF="#toc50">7.4. Lendo e gravando em arquivos externos</A>
      <UL>
      <LI><A HREF="#toc51">7.4.1. Lendo arquivos</A>
      <LI><A HREF="#toc52">7.4.2. Gravando arquivos</A>
      </UL>
    <LI><A HREF="#toc53">7.5. Trocando um trecho de texto por outro</A>
      <UL>
      <LI><A HREF="#toc54">7.5.1. Trocar várias linhas por uma</A>
      <LI><A HREF="#toc55">7.5.2. Trocar várias linhas por outras</A>
      </UL>
    <LI><A HREF="#toc56">7.6. Emulando outros comandos</A>
    </UL>
  <LI><A HREF="#toc57">Conceitos avançados</A>
    <UL>
    <LI><A HREF="#toc58">8.1. Monitorando um arquivo</A>
    <LI><A HREF="#toc59">8.2. Colocando comandos Sed num arquivo</A>
    <LI><A HREF="#toc60">8.3. Tornando arquivos Sed executáveis</A>
    <LI><A HREF="#toc61">8.4. Conhecendo os registradores internos</A>
      <UL>
      <LI><A HREF="#toc62">8.4.1. Apresentação</A>
      <LI><A HREF="#toc63">8.4.2. Exemplo</A>
      <LI><A HREF="#toc64">8.4.3. Exemplo gráfico</A>
      <LI><A HREF="#toc65">8.4.4. Resumão</A>
      <LI><A HREF="#toc66">8.4.5. Fluxograma</A>
      </UL>
    </UL>
  <LI><A HREF="#toc67">Fluxogramas</A>
    <UL>
    <LI><A HREF="#toc68">9.1. Fluxos do texto</A>
    <LI><A HREF="#toc69">9.2. Fluxos da execução dos comandos</A>
    <LI><A HREF="#toc70">9.3. Fluxos dos registradores internos</A>
    </UL>
  <LI><A HREF="#toc71">Nota sobre os adicionais GNU</A>
  <LI><A HREF="#toc72">Onde obter mais informações</A>
  </OL>

</DIV>
<DIV ID="main">

<A NAME="toc1"></A>
<H1>1. Sobre este documento</H1>

<A NAME="toc2"></A>
<H2>1.1. Descrição</H2>

<P>
Este documento se propõe a ser um <B>tutorial</B> e um <B>guia de consulta</B> de
<I>Sed</I> ao mesmo tempo.
</P>

<UL>
<LI><B>Tutorial</B> porque ele vai lhe apresentando o <I>Sed</I> aos poucos, explicando
  seu funcionamento.
<LI><B>Guia de consulta</B> porque ele tem dicas avançadas e descreve truques
  específicos que só serão assimilados e compreendidos executando-os na
  prática.
</UL>

<P>
Este documento <B>NÃO</B> abordará as <A HREF="http://aurelio.net/er">Expressões Regulares</A>,
que são um tema complexo, e embora façam parte da essência do <I>Sed</I>,
seu funcionamento independe delas.
</P>
<P>
Resumindo, o <I>Sed HOWTO</I> fala sobre <I>Sed</I>.
</P>
<P>
Este documento pode (deve) ser distribuído <B>à vontade</B>.
</P>

<A NAME="toc3"></A>
<H2>1.2. Anúncio</H2>

<P>
Este documento é algo que eu estava me devendo há séculos: uma
documentação decente em português sobre o <I>Sed</I> e seus detalhes.
</P>
<P>
É o <I>Sed HOWTO</I>, um misto de tutorial e guia de referência, com
exemplos práticos. A idéia é que sirva tanto aos principiantes
quanto aos iniciados, abrangendo conceitos básicos e complexos.
</P>
<P>
<B>http://aurelio.net/sed/sed-HOWTO</B>
</P>
<P>
Convido todos a visitarem e dar uma lida.
</P>
<P>
Além da versão html, o documento está disponível em texto, <S>sgml e pdf.</S>
<S>O sgml ainda pode ser convertido em info, dvi, tex, lyx, rtf e xml.</S>
</P>
<P>
Além de uma explicação bem detalhada, "gráfica" e didática dos
registradores internos e seus comandos
</P>
<P>
Com certeza, ainda tem <B>MUITA</B> coisa a melhorar/acrescentar.
Qualquer sugestão é bem-vinda.
</P>

<A NAME="toc4"></A>
<H2>1.3. Onde encontrá-lo</H2>

<P>
A casa oficial deste documento é na seção <I>Sed</I> do Site do Aurelio.
Você pode consultá-lo <I>on-line</I> ou baixá-lo para leitura local em
quaisquer dos formatos seguintes:
</P>

<TABLE ALIGN="center">
<TR>
<TH>formato</TH>
<TH>endereço</TH>
<TH>detalhe</TH>
</TR>
<TR>
<TD ALIGN="center">online</TD>
<TD><A HREF="http://aurelio.net/sed/sed-HOWTO/">http://aurelio.net/sed/sed-HOWTO/</A></TD>
<TD>várias páginas</TD>
</TR>
<TR>
<TD>impressão</TD>
<TD><A HREF="http://aurelio.net/sed/sed-HOWTO.html">http://aurelio.net/sed/sed-HOWTO.html</A></TD>
<TD>tudo-em-um</TD>
</TR>
<TR>
<TD ALIGN="center">txt</TD>
<TD><A HREF="http://aurelio.net/sed/sed-HOWTO.txt">http://aurelio.net/sed/sed-HOWTO.txt</A></TD>
<TD>versão texto</TD>
</TR>
</TABLE>

<A NAME="toc5"></A>
<H2>1.4. Registro de mudanças</H2>

<DL>
<DT>2009-06-26 — v0.6</DT><DD>
  <UL>
  <LI>Documento convertido para UTF-8
  <LI>A versão HTML de uma única página agora vem sem formatação (CSS)
    para facilitar a impressão
  <LI>Removidas as versões PDF e SGML deste documento, para facilitar
    sua manutenção
  <LI>Todos os links externos foram verificados e atualizados
  <LI>Agora as referências internas para outros tópicos são links
  <LI>Padronizado o nome "Sed" em vez de "sed" e "SED" ao referir-se ao programa
  <LI>Adicionado link e melhorada a tabela em <U>Emulando outros comandos</U>
  <LI>Melhorias nos desenhos ASCII (curvas com + e alinhamento)
  <LI>Melhorias de formatação na lista de agradecimentos
  <P></P>
  </UL>
<DT>2003-04-15 — v0.5</DT><DD>
  <UL>
  <LI>Listagem dos comandos adicionada em <U>Descrição de todos os comandos</U>
  <LI>Mudanças cosméticas, URLs atualizadas, s/endereçamento/endereço/g
  <LI>Adicionada versão HTML (tudo em uma página) e retirada a versão em
    PostScript (basta fazer <CODE>sgml2latex -o ps sed-HOWTO.sgml</CODE>)
  <LI>Retirado também o <CODE>.tgz</CODE> do ar
  <LI>O txt2tags (<A HREF="http://txt2tags.sf.net">http://txt2tags.sf.net</A>) agora é o conversor utilizado
    para gerar o Sed HOWTO - acabaram os títulos em CAPSLOCK
  <P></P>
  </UL>
<DT>2001-02-02 — v0.4</DT><DD>
  <UL>
  <LI>Documento disponibilizado agora também em ps e pdf
  <LI>Mais info na seção <U>Anúncio</U>, sobre os formatos novos
  <P></P>
  </UL>
<DT>2000-12-03 — v0.3</DT><DD>
  <UL>
  <LI>Criada seção <U>Trocando um trecho de texto por outro</U>
  <LI>Criada seção <U>Fluxos da execução dos comandos</U>
  <LI>Criada seção <U>Onde encontrá-lo</U>
  <LI>Exemplo gráfico didático em <U>Conhecendo os registradores internos</U>
  <LI>Informações mais didáticas na seção <U>Como ele funciona</U>
  <LI>Documento disponibilizado em txt e sgml
  <LI>Várias correções pequenas nos textos
  <P></P>
  </UL>
<DT>2000-09-13 — v0.2</DT><DD>
  <UL>
  <LI>Criada seção <U>Anúncio</U>
  <LI>Criada seção <U>Registro de mudanças</U>
  <LI>Criada seção <U>Agradecimentos</U>
  <LI>Disponibilizado este documento em HTML compactado
  <LI>Retirada entrada duplicada na seção <U>Emulando outros comandos</U>
  <P></P>
  </UL>
<DT>2000-08-2 — v0.1</DT><DD>
  <UL>
  <LI>1ª versão
  <LI>Disponibilização na internet
  </UL>
</DL>

<A NAME="toc6"></A>
<H2>1.5. Agradecimentos</H2>

<P>
Meus agradecimentos sinceros àqueles que comentaram, enviaram sugestões e
correções, ou ajudaram na divulgação, via e-mail ou internet.
</P>

<UL>
<LI>.*@conectiva
<LI>.*@lista_sed-br
<LI>.*@lista_sed-users
<LI>Carlos Alvsan
<LI>Eduardo Mendes
<LI>Rafael Steil
<LI>Rodrigo Bernardo Pimentel
<LI>Rubens Queiroz de Almeida &amp; Dicas-l
<LI>Sérgio Bruder &amp; .BR
<LI>Thobias Salazar Trevisan
<LI>Tiago Barros &amp; senha.org
</UL>

<A NAME="toc7"></A>
<H1>2. Conhecendo o sed</H1>

<P>
Vamos conhecer um pouco o <I>Sed</I>, mostrar que ele não é o bicho de
<I>Sed</I> cabeças que aparenta :)
</P>

<A NAME="toc8"></A>
<H2>2.1. Descrição do Sed</H2>

<P>
O <I>Sed</I> é um editor de textos <B>não interativo</B>.
</P>
<P>
Ele pode editar automaticamente, sem interação do usuário, vários arquivos
seguindo um conjunto de regras especificadas.
</P>

<A NAME="toc9"></A>
<H2>2.2. O que significa a palavra Sed</H2>

<P>
Vem do inglês "Stream EDitor", ou seja, editor de fluxos (de texto).
</P>

<A NAME="toc10"></A>
<H2>2.3. Como saber se devo usar o Sed</H2>

<P>
Sendo um editor de textos não interativo, o <I>Sed</I> é excelente para
desempenhar algumas tarefas, mas em outras seu uso não é aconselhado.
</P>

<A NAME="toc11"></A>
<H3>2.3.1. Quando usar o Sed</H3>

<P>
A característica principal do <I>Sed</I> é poder editar arquivos automaticamente.
</P>
<P>
Então sempre que você precisar fazer alterações sistemáticas em <B>vários</B>
arquivos, o <I>Sed</I> é uma solução eficaz.
</P>
<P>
Por exemplo, você tem um diretório cheio de relatórios de vendas, e
descobriu que por um erro na geração, todas as datas saíram erradas, com o
ano de <B>1999</B> onde era para ser <B>2000</B>. Num editor de textos normal, você tem
que abrir os relatórios um por um e alterar o ano em todas as ocorrências.
</P>
<P>
Certo, isso não é tão complexo se o editor de textos possuir uma ferramenta
de procura e troca, também chamado de substituição.
</P>
<P>
Mas então suponhamos que o erro da data não seja o ano, e sim o <B>formato</B>,
tendo saído como <B>mm/dd/aaaa</B> quando deveria ser <B>dd/mm/aaaa</B>. Aqui não é
uma substituição e sim uma troca de lugares, e uma ferramenta simples de
procura e troca não poderá ajudar.
</P>
<P>
Esse é um caso típico onde o <I>Sed</I> mostra seu poder: alterações complexas em
vários arquivos.
</P>
<P>
Utilizando o <I>Sed</I>, a solução para este problema (que veremos adiante) é até
simples, bastando definir uma série de regras de procura e troca, e o
programa se encarregará de executá-las e arrumar os relatórios.
</P>

<A NAME="toc12"></A>
<H3>2.3.2. Quando não usar o Sed</H3>

<P>
<B>Nenhuma</B> ferramenta é ideal para todas as tarefas, e o <I>Sed</I> não é uma
exceção à regra.
</P>

<H4>2.3.2.1. Edição genérica de textos</H4>

<P>
Ele <B>não</B> é prático para ser utilizado como editor de textos de uso genérico.
</P>
<P>
Para escrever textos, ou alterar coisas simples, é mais rápido e fácil
abrir um editor de textos interativo como o <I>vi</I> ou o <I>emacs</I> e fazer a
alteração "na mão".
</P>

<H4>2.3.2.2. Programação avançada</H4>

<P>
O <I>Sed</I> não é uma linguagem de programação completa, pois não possui
variáveis, funções matemáticas, interação com o sistema operacional, entre
outras limitações. Mas bem, ele é um <B>manipulador de texto</B> e não uma
linguagem de uso geral.
</P>
<P>
Algumas estruturas complexas podem ser simuladas com alguma técnica, mas se
o seu programa em <I>Sed</I> começou a inchar muito, é aconselhável reescrevê-lo
numa linguagem com mais recursos, como o <I>perl</I>.
</P>

<A NAME="toc13"></A>
<H1>3. Perdendo o medo do sed</H1>

<A NAME="toc14"></A>
<H2>3.1. Como ele funciona</H2>

<P>
O <I>Sed</I> funciona como um filtro, por onde você passa um texto <CODE>X</CODE> e ele joga
na saída um texto <CODE>Y</CODE>.
</P>
<P>
O texto <CODE>X</CODE> virou <CODE>Y</CODE> seguindo algumas regrinhas que você determinou.
</P>
<P>
Pense no <I>Sed</I> como um processador de alimentos, dependendo da lâmina
utilizada, a batata sai cortada de uma maneira diferente :)
</P>

<UL>
<LI>o <I>Sed</I> funciona como um filtro, ou conversor.
<P></P>
<LI>o <I>Sed</I> é orientado a linha, de cima para baixo, da esquerda para a direita.
<P></P>
<LI>o <I>Sed</I> lê uma linha da entrada padrão (STDIN) ou de um arquivo especificado,
  aplica os comandos de edição e mostra o resultado na saída padrão (STDOUT).
  vai para a próxima linha e repete o processo.
<P></P>
<LI>o <I>Sed</I> aceita endereços para os comandos.
<P></P>
<LI>o <I>Sed</I> aplica os comandos para todas as linhas caso um endereço não
  seja especificado.
<P></P>
<LI>o <I>Sed</I> faz uso intensivo de expressões regulares.
<P></P>
<LI>o <I>Sed</I> é macho :)
</UL>

<A NAME="toc15"></A>
<H2>3.2. Sua sintaxe</H2>

<P>
A sintaxe genérica de um comando <I>Sed</I> é:
</P>

<PRE>
sed [opções] regras [arquivo]
</PRE>

<P>
Sendo que <CODE>regras</CODE> tem a forma genérica de:
</P>

<PRE>
[endereço1 [, endereço2]] comando [argumento]
</PRE>

<A NAME="toc16"></A>
<H3>3.2.1. Exemplo</H3>

<P>
Como notação tradicional, o que está <CODE>[entre colchetes]</CODE> é opcional, então a
sintaxe <I>Sed</I> mais simples que existe é <CODE>sed regra</CODE> como em:
</P>

<PRE>
prompt$ cat texto.txt | sed p
</PRE>

<P>
Ou seja, o <I>Sed</I> lendo da entrada padrão o conteúdo do arquivo <I>texto.txt</I>
via duto <B><CODE>|</CODE></B>, aplica o comando <B><CODE>p</CODE></B> para todas as linhas do arquivo, ou seja,
as duplica.
</P>

<A NAME="toc17"></A>
<H3>3.2.2. Outros exemplos</H3>

<P>
Um outro exemplo do <I>Sed</I> com <CODE>opções</CODE> e recebendo um arquivo como parâmetro
seria:
</P>

<PRE>
prompt$ sed -n p texto.txt
</PRE>

<P>
E ainda, agora especificando um <B>endereço</B> para o comando <B><CODE>p</CODE></B>:
</P>

<PRE>
prompt$ sed -n 5p texto.txt
</PRE>

<P>
Ou seja, este comando imprime apenas a <B>linha 5</B> do <I>texto.txt</I>
</P>

<A NAME="toc18"></A>
<H2>3.3. Como executá-lo</H2>

<P>
A execução do <I>Sed</I> é igual a de outro aplicativo qualquer de manipulação de
texto, aceitando como parâmetro um nome de arquivo, ou na falta deste, lê o
texto da <B>entrada padrão</B>, via duto <B><CODE>|</CODE></B> ou redirecionamento <B><CODE>&lt;</CODE></B>.
</P>
<P>
E como dica geral <B>SEMPRE</B> coloque os comandos do <I>Sed</I> entre aspas simples '',
para evitar que o <I>shell</I> os interprete erroneamente. Veja mais detalhes no
tópico <i>Sed e shell</i>.
</P>

<PRE>
prompt$ sed 'p' texto.txt
prompt$ cat texto.txt | sed 'p'
prompt$ sed 'p' &lt; texto.txt
</PRE>

<P>
Com outra opção ainda, pode-se executar diretamente um arquivo com comandos
Sed. Para mais informações, veja o tópico <i>Tornando arquivos Sed executáveis</i>.
</P>

<A NAME="toc19"></A>
<H1>4. Os comandos do sed</H1>

<A NAME="toc20"></A>
<H2>4.1. Descrição de todos os comandos</H2>

<PRE>
prompt$ man sed
prompt$ pinfo sed
</PRE>

<P>
Ou num resumo rápido:
</P>

<PRE>
Legenda:

[ARQUIVO]       arquivo ou fluxo de texto (via pipe) original a ser modificado
[TEXTO]         trecho de texto. pode ser uma palavra, uma linha,
                várias separadas por \n, ou mesmo um vazio.
[PADRÃO]        [TEXTO] contido no ESPAÇO PADRÃO


=	imprime o número da linha atual do [ARQUIVO]
#	inicia um comentário
!	inverte a lógica do comando
;	separador de comandos
,	separador de faixas de endereço
{	início de bloco de comandos
}	fim de bloco de comandos

s	substitui um trecho de texto por outro
y	traduz um caractere por outro

i	insere um texto antes da linha atual 
c	troca a linha atual por um texto
a	anexa um texto após a linha atual

g	restaura o [TEXTO] contido no ESPAÇO RESERVA (sobrescrevendo)
G	restaura o [TEXTO] contido no ESPAÇO RESERVA (anexando)
h	guarda o [PADRÃO] no ESPAÇO RESERVA (sobrescrevendo)
H	guarda o [PADRÃO] no ESPAÇO RESERVA (anexando)
x	troca os conteúdos dos ESPAÇO PADRÃO e RESERVA

p	imprime o [PADRÃO]
P	imprime a primeira linha do [PADRÃO]
l	imprime o [PADRÃO] mostrando caracteres brancos

r	inclui conteúdo de um arquivo antes da linha atual
w	grava o [PADRÃO] num arquivo

:	define uma marcação
b	pula até uma marcação 
t	pula até uma marcação, se o último s/// funcionou (condicional)

d	apaga o [PADRÃO]
D	apaga a primeira linha do [PADRÃO]
n	vai para a próxima linha
N	anexa a próxima linha no [PADRÃO]
q	finaliza o Sed imediatamente

</PRE>

<A NAME="toc21"></A>
<H2>4.2. Lista de todos os comandos por categoria</H2>

<PRE>
                   informações =
                    marcadores :
                   comentários #
            comandos de edição s i c a y
     comandos de registradores g G h H x
         comandos de impressão p P l
           comandos de arquivo r w
                 modificadores g i !
                   separadores ; -e \n
             controle de fluxo b t d D n N q
                      endereço // ,
                   limitadores {} \(\)
       registradores dinâmicos \1 \2 ... \9
</PRE>

<A NAME="toc22"></A>
<H1>5. Conceitos básicos</H1>

<P>
Aqui vão conhecimentos que você <B>precisa</B> assimilar para fazer um bom uso do
<I>Sed</I>.
</P>

<A NAME="toc23"></A>
<H2>5.1. Suprimindo a saída padrão</H2>

<A NAME="toc24"></A>
<H3>5.1.1. Saída normal</H3>

<P>
Normalmente o <I>Sed</I> sempre imprime na <B>saída padrão</B> todas as linhas do
arquivo, modificadas ou não.
</P>
<P>
Veja o primeiro exemplo citado:
</P>

<PRE>
prompt$ sed 'p' texto.txt
</PRE>

<P>
O comando <B><CODE>p</CODE></B> imprime a linha na saída padrão. Este exemplo <B>duplica</B> todas
as linhas do arquivo pois, além da impressão normal de cada linha, ainda é
aplicado o comando <B><CODE>p</CODE></B> em cada uma, que diz "imprima esta linha", fazendo
com que ela apareça duas vezes.
</P>

<A NAME="toc25"></A>
<H3>5.1.2. Saída suprimida</H3>

<P>
Temos como modificar este comportamento com a opção <B><CODE>-n</CODE></B>, que significa
"não imprima na saída, a não ser quando especificado com o comando <B><CODE>p</CODE></B> ou o
<B><CODE>l</CODE></B>".
</P>
<P>
Assim sendo, colocando o <B><CODE>-n</CODE></B>, eliminamos o comportamento padrão de
"imprimir sempre na saída":
</P>

<PRE>
prompt$ sed -n 'p' texto.txt
</PRE>

<P>
Que resulta no conteúdo do arquivo, pois cada linha é impressa apenas uma
vez, devido ao comando <B><CODE>p</CODE></B>. Assim fica fácil entender como funciona o
exemplo já citado que imprime apenas a <B>linha 5</B> de um arquivo:
</P>

<PRE>
prompt$ sed -n 5p texto.txt
</PRE>

<P>
Ok, a explicação daquele <B>5</B> ali perdido vem logo a seguir no tópico
O endereço :)
</P>

<A NAME="toc26"></A>
<H2>5.2. O endereço</H2>

<P>
O endereço serve para você dizer ao <I>Sed</I> para aplicar um determinado
comando <B>apenas</B> nas linhas informadas. Este endereço pode ser descrito
direto como o <B>número</B> da linha, ou por <B>parte</B> de seu conteúdo (entre
<CODE>/barras/</CODE>).
</P>
<P>
Caso o endereço não seja informado, o comando <I>Sed</I> será aplicado para
<B>todas</B> as linhas.
</P>

<A NAME="toc27"></A>
<H3>5.2.1. Endereço simples</H3>

<P>
Por exemplo, referenciando a linha pelo seu número, como já foi visto
anteriormente:
</P>

<PRE>
prompt$ sed '5d' texto.txt
</PRE>

<P>
Mas também poderia ser uma linha que tivesse uma palavra qualquer:
</P>

<PRE>
prompt$ sed '/estorvo/d' texto.txt
</PRE>

<P>
O comando <B><CODE>d</CODE></B> apaga linhas segundo o endereço, então este comando
apagará todas as linhas que tiverem a palavra <CODE>estorvo</CODE>. Este exemplo tem o
funcionamento idêntico ao comando:
</P>

<PRE>
prompt$ grep -v estorvo texto.txt
</PRE>

<A NAME="toc28"></A>
<H3>5.2.2. Intervalo</H3>

<P>
Como endereço, ainda se pode especificar um <B>intervalo</B>, como da linha
5 até a linha 10, ou da linha 5 até a linha que tiver a palavra <CODE>estorvo</CODE>:
</P>

<PRE>
prompt$ sed '5,10d' texto.txt
prompt$ sed '5,/estorvo/d' texto.txt
</PRE>

<P>
No endereço, temos um caractere especial, o <B><CODE>$</CODE></B> que referencia à
<B>última</B> linha do texto. Assim sendo, para apagar da <B>linha 10</B> até o
<B>final</B> do texto, o comando é:
</P>

<PRE>
prompt$ sed '10,$d' texto.txt
</PRE>

<A NAME="toc29"></A>
<H3>5.2.3. Outros</H3>

<P>
No <I>Sed</I> da GNU, a partir da versão <B>3.02a</B>(*), foi adicionada uma maneira
nova de especificar um endereço:
</P>

<PRE>
prompt$ sed '/estorvo/,+3d' texto.txt
</PRE>

<P>
Que referencia a linha que contém a palavra <CODE>estorvo</CODE> e mais as <B>3</B> linhas
seguintes.
</P>
<P>
E pra finalizar, como já dito anteriormente, quando o comando <B>não</B> tem
endereço, é aplicado para todas as linhas:
</P>

<PRE>
prompt$ sed 'd' texto.txt
</PRE>

<P>
(*) veja o tópico <i>Nota sobre os adicionais GNU</i>
</P>

<A NAME="toc30"></A>
<H2>5.3. Interrompendo o processamento</H2>

<P>
A qualquer hora você pode <B>abortar</B> o comando <I>Sed</I> com o comando <B><CODE>q</CODE></B>.
</P>
<P>
Isso é útil no nosso exemplo anterior de emular o comando <I>head</I>,
imprimindo apenas as 10 primeiras linhas do arquivo:
</P>

<PRE>
sed '10q'         ao chegar na linha 10, pare.
</PRE>

<P>
Ou ainda, para obter apenas os cabeçalhos de uma mensagem de e-mail, que
são separados do corpo da mensagem por uma linha em branco:
</P>

<PRE>
sed '/^$/q'       pare na primeira linha em branco que achar
</PRE>

<A NAME="toc31"></A>
<H2>5.4. Invertendo a lógica</H2>

<P>
No <I>Sed</I> temos o modificador <B><CODE>!</CODE></B> que <B>inverte</B> a lógica do comando, ou seja
<CODE>!comando</CODE> significa "não execute o comando". É meio estranho a primeira
vista, mas você tem que começar a pensar como o <I>Sed</I>, e tudo se esclarece
:)
</P>
<P>
Temos o comando <I>head</I> que imprime as 10 primeiras linhas de um arquivo.
Com as dicas já vistas, podemos fazer esta tarefa com o <I>Sed</I> assim:
</P>

<PRE>
sed -n '1,10p'    imprima apenas da linha 1 até a 10
sed '11,$d'       apague da linha 11 até o final
</PRE>

<P>
Ou ainda, podemos inverter a lógica e fazer:
</P>

<PRE>
sed '1,10!d'      NÃO apague da linha 1 até a 10 (ou seja, apague as outras)
sed -n '11,$!p'   NÃO imprima da linha 11 até o final (ou seja, imprima as outras)
</PRE>

<P>
A dica é sempre complementar a leitura mental com o inverso (entre
parênteses nos exemplos), ou seja, se o <I>Sed</I> NÃO vai aplicar um comando em
determinadas linhas, isso quer dizer implicitamente que este comando
<B>será aplicado</B> em todas as outras linhas. É estranho, mas acostuma :)
</P>

<A NAME="toc32"></A>
<H2>5.5. Aplicando vários comandos de uma vez</H2>

<A NAME="toc33"></A>
<H3>5.5.1. Comandos normais</H3>

<P>
É possível aplicar vários comandos <I>Sed</I>, em <B>seqüência</B>. Basta
separá-los por ponto-e-vírgula.
</P>

<PRE>
prompt$ sed '5d;10d;/estorvo/d' texto.txt
</PRE>

<P>
Este comando apaga as linhas 5, 10 e as que têm <CODE>estorvo</CODE> do arquivo
<I>texto.txt</I>.
</P>

<A NAME="toc34"></A>
<H3>5.5.2. Comandos com parâmetros</H3>

<P>
Os comandos que recebem parâmetros (<B><CODE>r</CODE></B>, <B><CODE>w</CODE></B>, <B><CODE>i</CODE></B>, <B><CODE>a</CODE></B>, <B><CODE>c</CODE></B>), não aceitam
o ponto-e-vírgula como separador, pois este pode ser parte integrante do
parâmetro esperado.
</P>
<P>
Estes comandos devem ser separados dos restantes, sendo passados como
comandos isolados, pela opção de linha de comando <B><CODE>-e</CODE></B>:
</P>

<PRE>
prompt$ sed -e '1i começo de tudo' -e '5d' texto.txt
</PRE>

<P>
Este comando insere a frase <CODE>começo de tudo</CODE> antes da primeira linha e
apaga a quinta linha do arquivo <I>texto.txt</I>.
</P>

<A NAME="toc35"></A>
<H3>5.5.3. Terceira via</H3>

<P>
Outra maneira de especificar vários comandos (e a mais consistente e
garantida) é colocá-los num arquivo, um por linha. Veja o tópico
<i>Colocando comandos Sed num arquivo</i>.
</P>

<A NAME="toc36"></A>
<H1>6. Conceitos complementares</H1>

<P>
Estes são conhecimentos que possivelmente surgirão como dúvidas em sua
cabeça após utilizar o <I>Sed</I> por um tempo.
</P>

<A NAME="toc37"></A>
<H2>6.1. Sed e shell</H2>

<P>
Com o <I>Sed</I> sendo invocado na linha de comando, deve-se ter alguns cuidados
para evitar transtornos. O interpretador de comandos (shell), interpreta a
linha de comando antes de processá-la, então alguns caracteres especiais
como <B><CODE>$</CODE></B>, <B><CODE>\</CODE></B> e <B><CODE>!</CODE></B>, são interpretados pelo shell <B>antes</B> de chegarem ao
<I>Sed</I>, modificando o comportamento esperado.
</P>
<P>
Para evitar isso coloque os comandos <I>Sed</I> <B>sempre</B> entre aspas simples:
</P>

<PRE>
prompt$ sed 's/isso/aquilo/' texto.txt
</PRE>

<P>
Salvo quando no meio do comando <I>Sed</I>, existir algo que deva ser
interpretado, como uma variável por exemplo. Neste caso coloque os comandos
entre aspas duplas:
</P>

<PRE>
prompt$ sed "s/$HOME/aquilo/" texto.txt
</PRE>

<P>
Ou ainda, para evitar completamente a interpretação do shell, sem se
preocupar com aspas, coloque os comandos Sed num arquivo. Veja o tópico
<i>Colocando comandos Sed num arquivo</i>.
</P>

<A NAME="toc38"></A>
<H2>6.2. Usando outros delimitadores</H2>

<A NAME="toc39"></A>
<H3>6.2.1. No comando s</H3>

<P>
É comum ao fazer um comando de substituição <B><CODE>s///</CODE></B> conter uma
<B><CODE>/</CODE></B> num dos dois lados do comando, como quando querendo substituir
<CODE>/usr/local/bin</CODE> por <CODE>/usr/bin</CODE>.
</P>
<P>
Sendo a barra o delimitador do comando <B><CODE>s</CODE></B> as outras barras comuns devem
ser escapadas com a barra invertida <B><CODE>\</CODE></B>, para não serem confundidas com os
delimitadores normais, ficando o monstro a seguir:
</P>

<PRE>
prompt$ sed 's/\/usr\/local\/bin/\/usr\/bin/' texto.txt
</PRE>

<P>
Para evitar ter que ficar se escapando todas estas barras, basta lembrar
que o comando <B><CODE>s</CODE></B> aceita <B>qualquer</B> delimitador, sendo a barra apenas um
padrão de referências históricas. Então, neste caso, poderíamos escolher
outro delimitador como por exemplo a vírgula:
</P>

<PRE>
prompt$ sed 's,/usr/local/bin,/usr/bin,' texto.txt
</PRE>

<P>
Evitando-se de ter que ficar escapando as barras. A mesma dica vale para o
comando <B><CODE>y</CODE></B>.
</P>

<A NAME="toc40"></A>
<H3>6.2.2. No endereço</H3>

<P>
E se precisássemos apagar as linhas que contém o <CODE>/usr/local/bin</CODE>? Teríamos
que colocar o nome do diretório no endereço do comando <B><CODE>d</CODE></B>, voltando
com a festa dos escapes:
</P>

<PRE>
prompt$ sed '/\/usr\/local\/bin/d' texto.txt
</PRE>

<P>
Para usarmos outro delimitador no endereço, basta escaparmos o
primeiro, que no caso abaixo é a vírgula:
</P>

<PRE>
prompt$ sed '\,/usr/local/bin,d' texto.txt
</PRE>

<P>
Confusão de delimitadores com o texto a ser procurado é muito comum de
acontecer, então se algo não está funcionando como deveria, olhe com
cuidado para ver se não há conflitos entre eles.
</P>

<A NAME="toc41"></A>
<H2>6.3. Escapes para caracteres especiais</H2>

<P>
No <I>Sed</I> da GNU, a partir da versão <B>3.02.80</B>(*), vários escapes novos
foram adicionados e podem ser usados nas duas partes do comando <B><CODE>s///</CODE></B>:
</P>

<PRE>
   \a      beep             (apito)
   \f      form-feed        (avança linha)
   \n      newline          (quebra de linha)
   \r      carriage-return  (retorno de carro)
   \t      hTAB             (tabulação horizontal)
   \v      vTAB             (tabulação vertical)
   \oNNN   o caractere de valor octal NNN
   \dNNN   o caractere de valor decimal NNN
   \xNN    o caractere de valor hexadecimal NN
</PRE>

<P>
(*) veja o tópico <i>Nota sobre os adicionais GNU</i>
</P>

<A NAME="toc42"></A>
<H2>6.4. Gravando o resultado no mesmo arquivo</H2>

<A NAME="toc43"></A>
<H3>6.4.1. Problema inicial</H3>

<P>
O procedimento comum quando se quer gravar num arquivo o resultado de um
comando <I>Sed</I>, é o redirecionamento:
</P>

<PRE>
prompt$ sed 'comando' texto.txt &gt; texto-alterado.txt
</PRE>

<P>
Mas é muito comum, ao alterarmos um arquivo, queremos gravar estas
alterações no <B>próprio</B> arquivo original. A tentativa intuitiva seria:
</P>

<PRE>
prompt$ sed 'comando' texto.txt &gt; texto.txt
</PRE>

<P>
Mas é só fazer para ver. Além de não dar certo, você ainda perderá <B>todo</B> o
conteúdo do arquivo.
</P>
<P>
Isso acontece porque ao fazer o redirecionamento <B><CODE>&gt;</CODE></B>, o <CODE>shell</CODE> abre
imediatamente o arquivo referenciado, antes mesmo de começar a executar o
comando <I>Sed</I>. E como este é um redirecionamento destrutivo <B><CODE>&gt;</CODE></B> e não
incremental <B><CODE>&gt;&gt;</CODE></B>, se o arquivo já existir, ele será truncado, e seu
conteúdo perdido. A essa altura, o <I>Sed</I> começará seu processamento já
lendo um arquivo <I>texto.txt</I> vazio, e aplicados qualquer comandos
<I>Sed</I> num
arquivo vazio, o resultado será o próprio arquivo vazio.
</P>

<A NAME="toc44"></A>
<H3>6.4.2. Solução genérica</H3>

<P>
Para evitar isso, voltamos a primeira tática de gravar o resultado num
outro arquivo, e depois o mais natural é <B>mover</B> o arquivo novo sobre o
original:
</P>

<PRE>
prompt$ sed 'comando' texto.txt &gt; texto-alterado.txt
prompt$ mv texto-alterado.txt texto.txt
</PRE>

<P>
Para a grande maioria dos casos, isso é suficiente, mas convém aqui lembrar
que caso o arquivo 'texto.txt' possua atributos especiais, grupo diferente
do padrão do usuário, ou referências (links, simbólicos ou não) para outros
arquivos, tudo isso <B>será perdido</B>. Ao mover o arquivo recém-criado, com os
atributos padrão do sistema, sobre o original, este perderá seus atributos
e ficará com os padrões do sistema, <B>herdado</B> do arquivo novo.
</P>

<A NAME="toc45"></A>
<H3>6.4.3. Solução segura</H3>

<P>
Para evitar isso, a abordagem mais ortodoxa e segura seria aplicar o
comando <I>Sed</I> numa cópia e gravar o resultado no arquivo original via
redirecionamento:
</P>

<PRE>
prompt$ cp -a texto.txt texto-tmp.txt
prompt$ sed 'comando' texto-tmp.txt &gt; texto.txt
prompt$ rm texto-tmp.txt
</PRE>

<P>
Novamente, isso só é necessário com arquivos especiais, senão a solução com
o <I>mv</I> pode ser usada. Mas é importante ter em mente esta outra maneira e
principalmente saber o porque de utilizá-la, sendo este conhecimento
aplicável a qualquer outro comando do sistema que leia e grave arquivos.
</P>

<A NAME="toc46"></A>
<H1>7. Tarefas diversas</H1>

<A NAME="toc47"></A>
<H2>7.1. Como substituir alguma coisa por uma quebra de linha</H2>

<P>
No <I>Sed</I> da GNU, a partir da versão <B>3.02.80</B>(*), foi adicionado o <B><CODE>\n</CODE></B>
como escape válido dos dois lados do comando <B><CODE>s///</CODE></B>. Com isso a tarefa de
colocar cada palavra numa linha isolada, ou seja, trocar espaços em branco
por quebras de linha, fica trivial:
</P>

<PRE>
prompt$ sed 's/ /\n/g' texto.txt
</PRE>

<P>
Mas com outras versões do <I>Sed</I> que não entendem este escape, a quebra de
linha deve ser inserida <B>literalmente</B> e deve ser escapada:
</P>

<PRE>
prompt$ sed 's/ /\
prompt$ /g' texto.txt
</PRE>

<P>
Como curiosidade, a operação inversa, de colocar todas as linhas de um
arquivo numa linha só, já é mais trabalhosa e utiliza o conceito de <I>laço</I>:
</P>

<PRE>
prompt$ sed ':a;$!N;s/\n/ /g;ta'
</PRE>

<P>
(*) veja o tópico <i>Nota sobre os adicionais GNU</i>
</P>

<A NAME="toc48"></A>
<H2>7.2. Apagando linhas específicas</H2>

<P>
O comando para apagar linhas é o <B><CODE>d</CODE></B>.
</P>
<P>
O único detalhe nesta tarefa é especificar <B>quais</B> linhas você vai querer
apagar. Isso está  completamente coberto no tópico <i>O endereço</i>.
</P>

<A NAME="toc49"></A>
<H2>7.3. Como ignorar maiúsculas e minúsculas</H2>

<P>
O jeito padrão do <I>Sed</I> ser "ignore-case", é dizendo literalmente todas as
possibilidades, como em:
</P>

<PRE>
prompt$ sed '/[Rr][Oo][Oo][Tt]/d' texto.txt
</PRE>

<P>
Para apagar todas as linhas que contêm a palavra <CODE>root</CODE>, <CODE>ROOT</CODE>, <CODE>RooT</CODE>
etc.
</P>
<P>
No <I>Sed</I> da GNU, a partir da versão <B>3.01-beta1</B>(*), foi adicionado o
modificador <B><CODE>I</CODE></B> no endereço e no comando <B><CODE>s///</CODE></B>, fazendo com que o
comando acima fique mais simples:
</P>

<PRE>
prompt$ sed '/root/Id' texto.txt
</PRE>

<P>
Ou ainda:
</P>

<PRE>
prompt$ sed 's/root/administrador/Ig' texto.txt
</PRE>

<P>
(*) veja o tópico <i>Nota sobre os adicionais GNU</i>
</P>

<A NAME="toc50"></A>
<H2>7.4. Lendo e gravando em arquivos externos</H2>

<A NAME="toc51"></A>
<H3>7.4.1. Lendo arquivos</H3>

<P>
Uma tarefa comum é incluir cabeçalho e rodapé num arquivo qualquer. O
<I>Sed</I> possui um comando específico para ler arquivos, o <B><CODE>r</CODE></B>, então
basta(*):
</P>

<PRE>
prompt$ sed -e '1r cabecalho.txt' -e '$r rodape.txt' texto.txt
</PRE>

<P>
Para incluir o cabeçalho após a linha <B>1</B> e incluir o rodapé após a
<B>última</B> linha.
</P>
<P>
(*) a explicação do porquê das opções <B><CODE>-e</CODE></B> está no tópico
<i>Aplicando vários comandos de uma vez</i>.
</P>

<A NAME="toc52"></A>
<H3>7.4.2. Gravando arquivos</H3>

<P>
O comando <B><CODE>w</CODE></B> grava num arquivo a linha atual, ou melhor, o conteúdo do
<I>espaço padrão</I>. Por exemplo, você quer gravar num arquivo o resultado de
uma busca por linhas que contêm a palavra <CODE>estorvo</CODE>. A solução não-Sed
seria:
</P>

<PRE>
prompt$ grep 'estorvo' texto.txt &gt; estorvos.txt
</PRE>

<P>
Nosso similar em Sed seria:
</P>

<PRE>
prompt$ sed '/estorvo/w estorvos.txt' texto.txt
</PRE>

<P>
Gravar dados num arquivo também pode servir de <B>espaço auxiliar</B> caso o
<I>espaço reserva</I> não seja suficiente. Mas esta é uma opção drástica, não
tão flexível. Mais informações sobre o <I>espaço reserva</I> no tópico
<i>Conhecendo os registradores internos</i>.
</P>

<A NAME="toc53"></A>
<H2>7.5. Trocando um trecho de texto por outro</H2>

<P>
Uma tarefa que parece simples mas confunde, é trocar um trecho de texto,
como um parágrafo inteiro por exemplo, por outro trecho, independente do
número de linhas de ambos.
</P>

<A NAME="toc54"></A>
<H3>7.5.1. Trocar várias linhas por uma</H3>

<P>
Essa é simples, basta usar o comando <B><CODE>c</CODE></B>, que "Coloca" um texto no lugar da
linha atual. A única complicação é definir o <I>endereço</I>, para aplicar
o comando apenas nas linhas desejadas. Por exemplo, vamos colocar uma frase
no lugar de uma área de texto pré-formatado num documento HTML. Esta área é
delimitada pelos identificadores <B><CODE>&lt;pre&gt;</CODE></B> e <B><CODE>&lt;/pre&gt;</CODE></B>:
</P>

<PRE>
prompt$ sed '/&lt;pre&gt;/,/&lt;\/pre&gt;/c \
prompt$ aqui tinha texto pré-formatado' texto.html
</PRE>

<P>
Note que o comando <B><CODE>c</CODE></B> (assim como o <B><CODE>a</CODE></B> e o <B><CODE>i</CODE></B>) <B>exige</B> que o texto que
ele recebe como parâmetro esteja na linha seguinte, estando a quebra de
linha escapada com a barra invertida <B><CODE>\</CODE></B>
</P>
<P>
No <I>Sed</I> da GNU, a partir da versão <B>3.02a</B>(*), é permitido que se coloque
o texto na mesma linha:
</P>

<PRE>
prompt$ sed '/&lt;pre&gt;/,/&lt;\/pre&gt;/c aqui tinha texto pré-formatado' texto.html
</PRE>

<P>
(*) veja o tópico <i>Nota sobre os adicionais GNU</i>
</P>

<A NAME="toc55"></A>
<H3>7.5.2. Trocar várias linhas por outras</H3>

<P>
Similarmente a trocar por apenas uma linha, pode-se usar o comando <B><CODE>c</CODE></B> e
passar várias linhas para ele. O único detalhe é que todas as linhas devem
ser <B>escapadas</B> no final, menos a última:
</P>

<PRE>
prompt$ sed '/&lt;pre&gt;/,/&lt;\/pre&gt;/c \
prompt$ aqui tinha texto pré-formatado,\
prompt$ mas eu resolvi tirar.\
prompt$ porque?\
prompt$ porque sim' texto.html
</PRE>

<P>
É claro, quando o comando começa a ficar grande desse jeito, é melhor
colocá-lo num arquivo. Saiba mais detalhes sobre isso no tópico
<i>Colocando comandos sed num arquivo</i>.
</P>
<P>
Mas melhor ainda é separar o comando <I>Sed</I> do texto, colocando-o num
arquivo separado. Assim, quando se precisar alterar este texto, basta
editá-lo, sem mudar o comando <I>Sed</I>, e sem precisar ficar colocando <B><CODE>\</CODE></B> no
final de cada linha.
</P>
<P>
Supondo que nosso texto explicativo do porquê da retirada do texto
pré-formatado foi gravado no arquivo <I>desculpa.txt</I>, utilizaremos o comando
<B><CODE>r</CODE></B> para lê-lo e o comando <B><CODE>d</CODE></B> para apagar o texto antigo:
</P>

<PRE>
prompt$ sed -e '/&lt;\/pre&gt;/r desculpa.txt' -e '/&lt;pre&gt;/,/&lt;\/pre&gt;/d' texto.html
</PRE>

<P>
Então acompanhe o que acontece: o primeiro comando será executado apenas na
linha <CODE>&lt;/pre&gt;</CODE> que é o fechamento do trecho, então vamos esquecer dele por
enquanto. O segundo comando diz para apagar o trecho desde <CODE>&lt;pre&gt;</CODE> até
<CODE>&lt;/pre&gt;</CODE>, então assim que começar o trecho, ele vai apagando, linha por
linha.
</P>
<P>
Ao chegar na linha que contém o <CODE>&lt;/pre&gt;</CODE>, o primeiro comando <I>Sed</I> entra em
ação e lê o arquivo <I>desculpa.txt</I>, colocando seu conteúdo imediatamente
após a linha atual. Em seguida, o segundo comando apaga a linha <CODE>&lt;/pre&gt;</CODE>,
completando a tarefa.
</P>
<P>
Esta segunda solução é mais difícil de entender e implementar, mas é muito
mais prática caso a alteração do texto a ser colocado seja freqüente, além
destas alterações poderem ser feitas por alguém que nem saiba o que é
<I>Sed</I>, pois será apenas um texto normal.
</P>
<P>
Note que sempre que o <CODE>&lt;/pre&gt;</CODE> foi referenciado nos <I>endereços</I>, a
barra foi escapada, ficando <CODE>&lt;\/pre&gt;</CODE>. A explicação desse escape está em
<U>Usando outros delimitadores</U>
</P>
<P>
<B>obs.:</B> talvez o <CODE>&lt;pre&gt;&lt;/pre&gt;</CODE> não seja um exemplo dos mais didáticos, mas
não me veio algo mais comum à mente...
</P>

<A NAME="toc56"></A>
<H2>7.6. Emulando outros comandos</H2>

<P>
Aqui vão alguns exemplos de emulações de outros comandos usando-se o
<I>Sed</I>:
</P>

<TABLE ALIGN="center">
<TR>
<TH>comando</TH>
<TH>emulação</TH>
</TR>
<TR>
<TD>cat</TD>
<TD>sed :</TD>
</TR>
<TR>
<TD>head</TD>
<TD>sed 10q</TD>
</TR>
<TR>
<TD>grep</TD>
<TD>sed /padrão/!d</TD>
</TR>
<TR>
<TD>grep -v</TD>
<TD>sed /padrão/d</TD>
</TR>
<TR>
<TD>tac</TD>
<TD>sed 1!G;h;$!d</TD>
</TR>
<TR>
<TD>tail -1</TD>
<TD>sed $!d</TD>
</TR>
<TR>
<TD>tr A-Z a-z</TD>
<TD>sed y/ABCDEF...UVWXYZ/abcdef...uvwxyz/</TD>
</TR>
<TR>
<TD>wc -l</TD>
<TD>sed -n $=</TD>
</TR>
</TABLE>

<P>
A lista completa e atualizada pode ser encontrada em:
<A HREF="http://sed.sourceforge.net/local/docs/emulating_unix.txt">http://sed.sourceforge.net/local/docs/emulating_unix.txt</A>
</P>

<A NAME="toc57"></A>
<H1>8. Conceitos avançados</H1>

<P>
Estes são conhecimentos necessários àqueles que fazem uso intensivo do
<I>Sed</I>, fazendo programas grandes e/ou complexos.
</P>

<A NAME="toc58"></A>
<H2>8.1. Monitorando um arquivo</H2>

<P>
No <I>Sed</I> da GNU, a partir da versão <B>3.02.80</B>(*), foi adicionada a opção
-u, que significa "unbuffered", ou seja, faz um uso minimalista dos
registradores, mostrando a saída o mais rápido possível, tornando possível
editar um fluxo interminável como o gerado por um <I>tail -f</I>.
</P>
<P>
Um exemplo prático seria mostrar apenas as mensagens do sistema relativas
às conexões <I>ssh</I>:
</P>

<PRE>
prompt$ tail -f /var/log/messages | sed -nu '/sshd/p'
</PRE>

<P>
Cuidado com -nu perto de crianças! :)
</P>
<P>
(*) veja o tópico <i>Nota sobre os adicionais GNU</i>
</P>

<A NAME="toc59"></A>
<H2>8.2. Colocando comandos Sed num arquivo</H2>

<P>
Como os comandos <I>Sed</I> vão ficando extensos e complicados, é conveniente
colocá-los <B>num arquivo</B>, com estruturação e comentários.
</P>
<P>
Você pode espalhar os comandos por várias linhas, trocando o <B><CODE>;</CODE></B> por quebras
de linha e colocar <B>comentários</B> precedidos de <B><CODE>#</CODE></B>. O exemplo de apagar
linhas ficaria:
</P>

<PRE>
# programa.sed: apaga algumas linhas

# apaga a 5ª linha
5d

# apaga a 10ª linha
10d

# apaga as linhas que contêm 'estorvo'
/estorvo/d
</PRE>

<P>
Para dizer ao <I>Sed</I> para utilizar aquele arquivo como fonte de comandos,
basta usar a opção <B><CODE>-f</CODE></B>
</P>

<PRE>
prompt$ sed -f programa.sed texto.txt
</PRE>

<A NAME="toc60"></A>
<H2>8.3. Tornando arquivos Sed executáveis</H2>

<P>
O interpretador de comandos mais utilizado (<I>bash</I>) sempre procura na
<B>primeira</B> linha de um arquivo instruções para executá-lo.
</P>
<P>
Se um arquivo é um programinha em <I>shell</I>, basta colocar
</P>

<PRE>
#!/bin/sh
</PRE>

<P>
Na primeira linha para que o <I>bash</I> saiba que deve executá-lo com o
comando <CODE>/bin/sh</CODE>. O mesmo funciona para qualquer outro interpretador,
como o <I>Sed</I>. então para tornar um arquivos de comandos <I>Sed</I>
executável basta colocar como primeira linha:
</P>

<PRE>
#!/bin/sed -f
</PRE>

<P>
E é claro, torná-lo executável:
</P>

<PRE>
prompt$ chmod +x programa.sed
</PRE>

<P>
E na linha de comando, chame-o normalmente:
</P>

<PRE>
prompt$ ./programa.sed texto.txt
prompt$ cat texto.txt | ./programa.sed
</PRE>

<A NAME="toc61"></A>
<H2>8.4. Conhecendo os registradores internos</H2>

<A NAME="toc62"></A>
<H3>8.4.1. Apresentação</H3>

<P>
O <I>Sed</I> possui 2 registradores ("buffers") internos, que são usados para a
manipulação do texto.
</P>
<P>
Um deles é o <I>espaço padrão</I> ("pattern space"), que é o registrador
utilizado normalmente pelo <I>Sed</I>. É nele que a linha a ser processada é
armazenada e manipulada.
</P>
<P>
O outro é o <I>espaço reserva</I> ("hold space"), que é um registrador auxiliar,
inicialmente vazio, que serve para guardar uma cópia da linha original,
parte dela, ou agrupar dados diversos de várias linhas.
</P>
<P>
Há comandos para fazer a troca de dados entre os dois registradores:
</P>

<PRE>
  h      guarda no espaço reserva
  H      guarda (anexando) no espaço reserva

  g      pega o conteúdo do espaço reserva
  G      pega (anexando) o conteúdo do espaço reserva

  x      troca os conteúdos dos 2 registradores
</PRE>

<P>
O <I>anexando</I> acima significa "não sobrescreve o conteúdo original", ou
seja, ele mantém o que já tem, e adiciona um <B><CODE>\n</CODE></B> (quebra de linha),
seguido do texto manipulado. Para entender melhor, veja o exemplo gráfico
a seguir.
</P>

<A NAME="toc63"></A>
<H3>8.4.2. Exemplo</H3>

<P>
Um exemplo didático de uso do <I>espaço reserva</I> é ir guardando nele algumas
linhas do texto e mostrá-las depois no final do arquivo:
</P>

<PRE>
prompt$ sed '/root/H;$g' /etc/passwd
</PRE>

<P>
Ou seja, adicione no <I>espaço reserva</I> (comando <B><CODE>H</CODE></B>), as linhas que contêm a
palavra <CODE>root</CODE> e na última linha do arquivo (endereço <B><CODE>$</CODE></B>), recupere o
conteúdo do <I>espaço reserva</I> (comando <B><CODE>g</CODE></B>).
</P>

<A NAME="toc64"></A>
<H3>8.4.3. Exemplo gráfico</H3>

<P>
Como os registradores são a parte mais <B>obscura</B> do <I>Sed</I> (mais por falta
de documentação do que por complexidade), merecem uma explicação <B>bem</B>
didática. Vamos lá.
</P>
<P>
Temos os dois registradores vazios:
(que daqui pra frente serão chamados apenas de <I>padrão</I> e <I>reserva</I>)
</P>

<PRE>
      __________________                __________________
     |                  |              |                  |
     |                  |              |                  |
     |__________________|              |__________________|
        espaço padrão                     espaço reserva
</PRE>

<P>
E um arquivo hipotético com o conteúdo:
(não são odiosos estes exemplos com frutas?)
</P>

<PRE>
laranja
uva
abacaxi
melancia
mimosa
</PRE>

<P>
E aplicaremos o comando:
</P>

<PRE>
sed '/laranja/h ; /uva/g ; /abacaxi/H ; /melancia/G ; /mimosa/x'
</PRE>

<P>
Obtendo como resultado:
</P>

<PRE>
laranja
laranja
abacaxi
melancia
laranja
abacaxi
laranja
abacaxi
</PRE>

<P>
Vejamos o que aconteceu. Lida a primeira linha <CODE>laranja</CODE>, ela é
imediatamente colocada no <I>padrão</I> para ser manipulada:
</P>

<PRE>
      __________________                __________________
     |                  |              |                  |
     |      laranja     |              |                  |
     |__________________|              |__________________|
        espaço padrão                     espaço reserva
</PRE>

<P>
O comando direcionado a ela é o <B><CODE>h</CODE></B>, que guarda uma cópia dela no
<I>reserva</I>:
</P>

<PRE>
      __________________                __________________
     |                  |              |                  |
     |      laranja     |   -- h --&gt;   |      laranja     |
     |__________________|              |__________________|
        espaço padrão                     espaço reserva
</PRE>

<P>
Como mais nenhum comando é relativo à linha <CODE>laranja</CODE>, o <I>Sed</I> dá por
encerrado o processamento dessa linha e imprime o conteúdo do <I>padrão</I> na
saída: "laranja".
</P>
<P>
Beleza, agora ele vai processar a segunda linha, novamente a primeira coisa
é colocá-la no <I>padrão</I>, sobrescrevendo o que tinha antes:
</P>

<PRE>
      __________________                __________________
     |                  |              |                  |
     |        uva       |              |      laranja     |
     |__________________|              |__________________|
        espaço padrão                     espaço reserva
</PRE>

<P>
O <I>reserva</I>, enquanto nenhum outro comando escrever nele, permanecerá o
mesmo. O comando direcionado à linha <CODE>uva</CODE> é o <B><CODE>g</CODE></B>, que pega o conteúdo do
<I>reserva</I> e o coloca no <I>padrão</I>, apagando o que estiver nele (neste caso:
<CODE>uva</CODE>):
</P>

<PRE>
      __________________                __________________
     |                  |              |                  |
     |      laranja     |   &lt;-- g --   |      laranja     |
     |__________________|              |__________________|
        espaço padrão                     espaço reserva
</PRE>

<P>
Novamente, não há mais comandos a ser executados, então imprime na saída o
conteúdo do <I>padrão</I>: "laranja".
</P>
<P>
Indo para a terceira linha e colocando-a no <I>padrão</I>:
</P>

<PRE>
      __________________                __________________
     |                  |              |                  |
     |      abacaxi     |              |      laranja     |
     |__________________|              |__________________|
        espaço padrão                     espaço reserva
</PRE>

<P>
O comando dessa linha é o <B><CODE>H</CODE></B>, que tal como o <B><CODE>h</CODE></B>, guarda o conteúdo do
<I>padrão</I> no <I>reserva</I>, com diferença que ele preserva o conteúdo já
existente dele, separando com um <B><CODE>\n</CODE></B>:
</P>

<PRE>
      __________________                __________________
     |                  |              |                  |
     |      abacaxi     |   -- H --&gt;   | laranja\nabacaxi |
     |__________________|              |__________________|
        espaço padrão                     espaço reserva
</PRE>

<P>
Novamente, chegou ao fim, imprime o <I>padrão</I>: "abacaxi".
a próxima linha é a da <CODE>melancia</CODE>:
</P>

<PRE>
      __________________                __________________
     |                  |              |                  |
     |     melancia     |              | laranja\nabacaxi |
     |__________________|              |__________________|
        espaço padrão                     espaço reserva
</PRE>

<P>
E agora vai ficar divertido, aplicando o comando <B><CODE>G</CODE></B>, que pega o conteúdo
do <I>reserva</I> e anexa ao <I>padrão</I>:
</P>

<PRE>
 ____________________________           __________________
|                            |         |                  |
| melancia\nlaranja\nabacaxi |  &lt;-G--  | laranja\nabacaxi |
|____________________________|         |__________________|
        espaço padrão                    espaço reserva
</PRE>

<P>
E a saída agora fica "melancia\nlaranja\nabacaxi", com o detalhe que o
<I>Sed</I> troca estes <B><CODE>\n</CODE></B> por quebras de linha na impressão. Então são 3
linhas na saída. Vá acompanhando com o resultado que já foi cantado
antecipadamente lá em cima.
</P>
<P>
E finalmente, a última linha:
</P>

<PRE>
      __________________                __________________
     |                  |              |                  |
     |      mimosa      |              | laranja\nabacaxi |
     |__________________|              |__________________|
        espaço padrão                     espaço reserva
</PRE>

<P>
E para ela, o comando que troca o conteúdo dos 2 registradores, o <B><CODE>x</CODE></B>:
</P>

<PRE>
      __________________                __________________
     |                  |              |                  |
     | laranja\nabacaxi |  &lt;-- x ---&gt;  |      mimosa      |
     |__________________|              |__________________|
        espaço padrão                     espaço reserva
</PRE>

<P>
E mostra na saída o <I>padrão</I>, com duas linhas: "laranja" e "abacaxi".
</P>
<P>
Ufa! Depois dessa não venha me dizer que não sabe como funcionam os
<I>registradores internos</I> do <I>Sed</I> ;)
</P>

<A NAME="toc65"></A>
<H3>8.4.4. Resumão</H3>

<UL>
<LI>Cada linha nova lida é colocada (sobrescrevendo) no <I>espaço padrão</I>
<LI>Uma vez colocado algo no <I>espaço reserva</I>, fica lá até ser sobrescrito
<LI>O <B><CODE>\n</CODE></B> é o separador do conteúdo original com o anexo
<LI>Na saída, o <B><CODE>\n</CODE></B> vira quebra de linha
<LI>Registradores são simples! ;)
</UL>

<A NAME="toc66"></A>
<H3>8.4.5. Fluxograma</H3>

<P>
Para uma representação gráfica dos fluxos e comandos que manipulam estes
registradores, veja o tópico <i>Fluxos dos registradores internos</i>.
</P>

<A NAME="toc67"></A>
<H1>9. Fluxogramas</H1>

<A NAME="toc68"></A>
<H2>9.1. Fluxos do texto</H2>

<PRE>
                                  _________
                            w    |         |   r
                        +-------&gt;| ARQUIVO |-------&gt;
                        |        |_________|
                  ______|______                       SAÍDA
            n    |             |           p P l
ENTRADA  -------&gt;|    S E D    |-------------------&gt;
            N    |_____________|           a i c
                        |
                        |   d
                        +-------&gt; /dev/null
                            D

</PRE>

<A NAME="toc69"></A>
<H2>9.2. Fluxos da execução dos comandos</H2>

<PRE>
           _________
          |         |
    ______| próxima |&lt;---+
   /      |  linha  |    |
   |      |_________|    |
   |                     |
   v                 d D | n N
                    _____|______
                   |            |
COMEÇO   ---------&gt;|  COMANDOS  |----------&gt; FIM DO PROGRAMA
                   |____________|  q
                     |       ^
                   b | t     |
                     |       |
                     |    ___|______
                     |   |          |
                     +--&gt;| marcação |
                         |__________|


</PRE>

<A NAME="toc70"></A>
<H2>9.3. Fluxos dos registradores internos</H2>

<PRE>
 _________________               __________________
|                 |---- h H ---&gt;|                  |
|  ESPAÇO PADRÃO  |&lt;---  x  ---&gt;|  ESPAÇO RESERVA  |
|_________________|&lt;--- g G ----|__________________|


</PRE>

<P>
Veja explicação sobre estes registradores no tópico
<i>Conhecendo os registradores internos</i>.
</P>

<A NAME="toc71"></A>
<H1>10. Nota sobre os adicionais GNU</H1>

<P>
O <I>Sed</I> da GNU, atualmente é o utilizado pela maioria das distribuições de
Linux e é o que tem mais funcionalidades novas.
</P>
<P>
Mas o preço de se usar essas funcionalidades é que se perde em
<B>compatibilidade</B>, pois seu programa <I>Sed</I> não funcionará em UNIXes ou
outros sistemas que usem um <I>Sed</I> que não o da GNU.
</P>
<P>
Para a grande maioria dos usuários isso não fará diferença pois geralmente
trabalham com apenas um tipo de sistema operacional, mas o recado fica
dado.
</P>

<A NAME="toc72"></A>
<H1>11. Onde obter mais informações</H1>

<P>
Informações em português:
</P>

<UL>
<LI><A HREF="http://aurelio.net/sed">http://aurelio.net/sed</A>
</UL>

<P>
Informações em inglês:
</P>

<UL>
<LI><A HREF="http://sed.sourceforge.net/sed1line.txt">http://sed.sourceforge.net/sed1line.txt</A>
<LI><A HREF="http://sed.sourceforge.net/sedfaq.html">http://sed.sourceforge.net/sedfaq.html</A>
<LI><A HREF="http://www.dreamwvr.com/sed-info/sed-faq.html">http://www.dreamwvr.com/sed-info/sed-faq.html</A>
<LI><A HREF="http://www.rtfiber.com.tw/~changyj/sed">http://www.rtfiber.com.tw/~changyj/sed</A>
</UL>

<P>
Última versão em desenvolvimento do Sed:
</P>

<UL>
<LI><A HREF="ftp://alpha.gnu.org/gnu/sed">ftp://alpha.gnu.org/gnu/sed</A>
</UL>

</DIV>

<!-- html code generated by txt2tags 2.6b (http://txt2tags.sf.net) -->
<!-- cmdline: txt2tags sed-HOWTO/tudo.t2t -->
</BODY></HTML>
