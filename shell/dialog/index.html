---
title: Dialog --tudo
date: 2003-06-25
---

<!--
  BANCO DE HORAS

  Junho de 2003 (v0.1)
  dia 20 | 3 horas | 21:30-23:30
  dia 21 | 4 horas | 16:30-20:30
  dia 23 | 4 horas | 09:00-13:00
  dia 23 | 1 hora  | 14:00-15:00
  dia 23 | 4 horas | 19:00-23:00
  dia 24 | 4 horas | 09:00-13:00
  dia 24 | 3 horas | 21:30-00:30
  dia 25 | 4 horas | 08:30-12:30
  TOTAL: 27 horas

  v2: 3h (pesquisa+texto)
  v5: 5h
-->

<div class="note">
  <table>
    <tr>
      <td>
        <a href="http://www.shellscript.com.br"><img class="center" src="/img/icon/128/livroshell.png" alt=""></a>
      </td>
    </tr>
    <tr>
      <td>
        Este artigo sobre o Dialog é um resumo do capítulo 11 do meu livro <a href="http://www.shellscript.com.br">Shell Script Profissional</a>. O livro é enorme, são quase 500 páginas de puro shell, explicado de maneira clara e didática. Você vai dominar o assunto, além de aprender a escrever programas de verdade em vez de meros scripts toscos. Sou escritor e ganho a vida com meus livros, então comprando o livro você também me ajuda a manter esse site no ar e assim eu continuo escrevendo para você ler. Combinado? :)
      </td>
    </tr>
  </table>
</div>

<nav>
  <ol>
    <li>
      <a href="#prefacio">Prefácio</a>
    </li>
    <li>
      <a href="#intro">Introdução</a>
      <ul>
        <li>
          <a href="#oqueeh">2.1. O que é o Dialog</a>
        </li>
        <li>
          <a href="#historia">2.2. Breve histórico do Dialog</a>
        </li>
        <li>
          <a href="#primeiro">2.3. Seu primeiro comando com o Dialog</a>
        </li>
        <li>
          <a href="#caixas">2.4. Listagem dos 15 tipos de caixas</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="#exemplos">Exemplos dos tipos de caixa</a>
      <ul>
        <li>
          <a href="#calendar">3.1. Calendar</a>
        </li>
        <li>
          <a href="#checklist">3.2. Checklist</a>
        </li>
        <li>
          <a href="#fselect">3.3. Fselect</a>
        </li>
        <li>
          <a href="#gauge">3.4. Gauge</a>
        </li>
        <li>
          <a href="#infobox">3.5. Infobox</a>
        </li>
        <li>
          <a href="#inputbox">3.6. Inputbox, Passwordbox</a>
        </li>
        <li>
          <a href="#menu">3.7. Menu</a>
        </li>
        <li>
          <a href="#msgbox">3.8. Msgbox</a>
        </li>
        <li>
          <a href="#radiolist">3.9. Radiolist</a>
        </li>
        <li>
          <a href="#tailbox">3.10. Tailbox, Tailboxbg</a>
        </li>
        <li>
          <a href="#textbox">3.11. Textbox</a>
        </li>
        <li>
          <a href="#timebox">3.12. Timebox</a>
        </li>
        <li>
          <a href="#yesno">3.13. Yesno</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="#funcionamento">Como o Dialog funciona</a>
      <ul>
        <li>
          <a href="#parametros">4.1. Entendendo os parâmetros obrigatórios da linha de comando</a>
        </li>
        <li>
          <a href="#simnao">4.2. Como reconhecer respostas SIM ou NÃO</a>
        </li>
        <li>
          <a href="#textodigitado">4.3. Como obter o texto que o usuário digitou</a>
        </li>
        <li>
          <a href="#itemescolhido">4.4. Como obter o item único escolhido de um Menu ou Radiolist</a>
        </li>
        <li>
          <a href="#itensescolhidos">4.5. Como obter os itens múltiplos escolhidos de um Checklist</a>
        </li>
        <li>
          <a href="#botaocancelar">4.6. E se o usuário apertar o botão CANCELAR?</a>
        </li>
        <li>
          <a href="#teclaesc">4.7. E se o usuário apertar a tecla ESC?</a>
        </li>
        <li>
          <a href="#botaohelp">4.8. E se o usuário apertar o botão HELP?</a>
        </li>
        <li>
          <a href="#tratarbotoes">4.9. Como tratar todos os botões e teclas de uma vez?</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="#mergulhando">Mergulhando de cabeça no Dialog</a>
      <ul>
        <li>
          <a href="#menuloop">5.1. Exemplo de menu amarrado (em loop)</a>
        </li>
        <li>
          <a href="#encadeado">5.2. Exemplo de telas encadeadas (navegação sem volta)</a>
        </li>
        <li>
          <a href="#idaevolta">5.3. Exemplo de telas com navegação completa (ida e volta)</a>
        </li>
        <li>
          <a href="#confirmacao">5.4. Exemplo de pedido de confirmação (uma caixa sobre outra)</a>
        </li>
        <li>
          <a href="#posicionar">5.5. Exemplo de posicionamento de caixas (não centralizado)</a>
        </li>
        <li>
          <a href="#multicaixas">5.6. Exemplo de várias caixas na mesma tela (multicaixas!)</a>
        </li>
        <li>
          <a href="#menudinamico">5.7. Exemplo de menu com itens dinâmicos (definidos em execução)</a>
        </li>
        <li>
          <a href="#copiagauge">5.8. Exemplo de cópia de arquivos com barra de progresso (Gauge)</a>
        </li>
        <li>
          <a href="#cores">5.9. Configurando as cores das caixas</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="#opcoes">APÊNDICE A: Lista das opções de linha de comando</a>
      <ul>
        <li>
          <a href="#opcoes-textos">6.1. Opções para definir os textos da caixa</a>
        </li>
        <li>
          <a href="#opcoes-ajustes-textos">6.2. Opções para fazer ajustes no texto da caixa</a>
        </li>
        <li>
          <a href="#opcoes-ajustes">6.3. Opções para fazer ajustes na caixa</a>
        </li>
        <li>
          <a href="#opcoes-dados">6.4. Opções relativas aos dados informados pelo usuário</a>
        </li>
        <li>
          <a href="#opcoes-sozinhas">6.5. Opções que devem ser usadas sozinhas na linha de comando</a>
        </li>
        <li>
          <a href="#opcoes-outras">6.6. Outras opções</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="#clones">APÊNDICE B: Os clones: Xdialog, Kdialog, gdialog, ...</a>
      <ul>
        <li>
          <a href="#whiptail">7.1. Whiptail</a>
        </li>
        <li>
          <a href="#xdialog">7.2. Xdialog</a>
        </li>
        <li>
          <a href="#kdialog">7.3. Kdialog</a>
        </li>
        <li>
          <a href="#gdialog">7.4. gdialog</a>
        </li>
        <li>
          <a href="#zenity">7.5. Zenity</a>
        </li>
        <li>
          <a href="#udpm">7.6. Udpm</a>
        </li>
        <li>
          <a href="#pythondialog">7.7. pythondialog</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="#sobre">Sobre este documento</a>
      <ul>
        <li>
          <a href="#download">8.1. Disponibilidade (download)</a>
        </li>
        <li>
          <a href="#changelog">8.2. Histórico de versões (Changelog)</a>
        </li>
        <li>
          <a href="#licenca">8.3. Licença / Copyright</a>
        </li>
        <li>
          <a href="#maisinfo">8.4. Onde obter mais informações</a>
        </li>
      </ul>
    </li>
  </ol>
</nav>

<h2 id="prefacio">1. Prefácio</h2>

<p>Bem-vindo(a) ao "Dialog --tudo", uma documentação completa do programa Dialog escrita em português.</p>

<p>O Dialog é um programa usado para desenhar interfaces amigáveis para o usuário, com botões e menus, a partir de um Shell Script.</p>

<p>Um <a href="/shell">Shell Script</a> é um programa feito para funcionar no interpretador de comandos (prompt) padrão do UNIX/Linux, como o Bourne Shell, ou o Bash.</p>

<p>Para obter os conhecimentos que este documento se propõe a transmitir, o leitor deve ter:</p>

<ul>
  <li>Conhecimento prévio de programação Shell;</li>
  <li>Uma Shell disponível para testar os exemplos;</li>
  <li>O Dialog instalado e funcionando em sua máquina.</li>
</ul>

<p>Se você ainda não tem o Dialog, instale o programa direto do CD da sua distribuição de Linux, ou <a href="http://dickey.his.com/dialog/">baixe os fontes</a>.</p>

<p>Tudo certo? Então boa leitura!</p>

<h2 id="intro">2. Introdução</h2>

<h3 id="oqueeh">2.1. O que é o Dialog</h3>

<p>O Dialog é um programa para console (modo texto) que desenha caixas de diálogo ("dialog boxes") na tela, similares as do modo gráfico, com botões, entradas para texto e menu. Essas caixas são utilizadas para compor interfaces amigáveis com o usuário, para que ele responda perguntas ou escolha opções.</p>

<p>O Dialog é um executável e recebe todos os parâmetros via linha de comando, então ele geralmente é usado dentro de um Shell Script. Serve para fazer programas <strong>interativos</strong>, que o usuário precisa operar durante sua execução. Tarefas comuns feitas com o Dialog são escolher uma opção em um menu, escolher um arquivo, uma data, e digitar frases ou senhas.</p>

<p>Com o Dialog é possível fazer programas em shell que se "parecem" com programas gráficos, onde o usuário vê apenas telas e navega entre elas apertando os botões de "OK" e "CANCELAR". Um exemplo clássico desse tipo de interface são os programas de instalação de software.</p>

<p>Utilizando este conceito de telas, é possível "amarrar" o usuário ao programa, lhe apresentando as opções disponíveis, sem que ele precise ter acesso direto à linha de comando. Útil para logins restritos e para ajudar iniciantes.</p>

<h3 id="historia">2.2. Breve histórico do Dialog</h3>

<ul>
  <li>O Dialog original é antigo e não é mais desenvolvido, foi até a versão 0.3</li>
  <li>Outros programadores o adotaram e continuaram o desenvolvimento até a versão 0.7.</li>
  <li>Depois surgiu o "cdialog" (ComeOn Dialog), como um Dialog melhorado, baseado no original.</li>
  <li>O cdialog continuou evoluindo e acabou se tornando o oficial, sendo renomeado para "dialog". <strong>Este é o Dialog que veremos aqui.</strong></li>
</ul>

<h3 id="primeiro">2.3. Seu primeiro comando com o Dialog</h3>

<p>Mas vamos direto a um exemplo para que você conheça "a cara" do Dialog. Sente numa posição confortável e digite na shell o seguinte comando:</p>

<pre>
$ dialog --msgbox 'minha primeira tela' 5 40
</pre>

<p>Imediatamente sua tela ficará assim:</p>

<p class="figure">
  <img src="primeira.png">
</p>

<p>Fácil não? Desenhamos uma caixa de mensagens (msgbox) de tamanho 5 por 40.</p>

<p>O Dialog reconhece vários tipos de "caixas", e esta <em>msgbox</em> é uma das mais simples. Os dois números passados no final do comando definem o tamanho da caixa que queremos desenhar, nesse caso 5 linhas e 40 colunas (Não confundir com pixels, pois estamos no console!).</p>

<h3 id="caixas">2.4. Listagem dos 15 tipos de caixas</h3>

<p>Para saciar a curiosidade do leitor, aqui estão listados todos os tipos de caixa suportadas pelo Dialog:</p>

<table class="tableborder">
  <tr>
    <th>Tipo da caixa</th>
    <th>Desenha uma caixa onde o usuário...</th>
  </tr>
  <tr>
    <td>calendar</td>
    <td>Vê um calendário e escolhe uma data</td>
  </tr>
  <tr>
    <td>checklist</td>
    <td>Vê uma lista de opções e escolhe várias</td>
  </tr>
  <tr>
    <td>fselect</td>
    <td>Digita ou escolhe um arquivo</td>
  </tr>
  <tr>
    <td>gauge</td>
    <td>Vê uma barra de progresso (porcentagem)</td>
  </tr>
  <tr>
    <td>infobox</td>
    <td>Vê uma mensagem, sem botões</td>
  </tr>
  <tr>
    <td>inputbox</td>
    <td>Digita um texto qualquer</td>
  </tr>
  <tr>
    <td>menu</td>
    <td>Vê um menu e escolhe um item</td>
  </tr>
  <tr>
    <td>msgbox</td>
    <td>Vê uma mensagem e aperta o botão OK</td>
  </tr>
  <tr>
    <td>passwordbox</td>
    <td>Digita uma senha</td>
  </tr>
  <tr>
    <td>radiolist</td>
    <td>Vê uma lista de opções e escolhe uma</td>
  </tr>
  <tr>
    <td>tailbox</td>
    <td>Vê a saída do comando tail -f</td>
  </tr>
  <tr>
    <td>tailboxbg</td>
    <td>Vê a saída do comando tail -f (em segundo plano)</td>
  </tr>
  <tr>
    <td>textbox</td>
    <td>Vê o conteúdo de um arquivo</td>
  </tr>
  <tr>
    <td>timebox</td>
    <td>Escolhe um horário</td>
  </tr>
  <tr>
    <td>yesno</td>
    <td>Vê uma pergunta e aperta o botão YES ou o NO</td>
  </tr>
</table>

<p>É notável que a variedade é grande e temos caixas para vários tipos de tarefas. Algumas caixas são novas e foram introduzidas em versões mais recentes do Dialog.</p>

<p>Caso alguma dessas caixas não funcione na sua máquina, atualize o seu Dialog para a versão mais recente ou confira se ele foi compilado com todas as caixas disponíveis.</p>

<h2 id="exemplos">3. Exemplos dos tipos de caixa</h2>

<p>Agora que já sabemos como é a cara do Dialog, e quais são todos os tipos de caixas disponíveis, com certeza o leitor deve estar afoito para cruzar essas duas informações e ver a cara de todas as caixas, não?</p>

<p>É isso o que veremos agora, uma listagem completa com um exemplo funcional de cada tipo de caixa, constando um foto da tela e a linha de comando usada para gerá-la.</p>

<p>Como uma maneira de contextualizar nossa listagem, inventamos o <strong>IIV</strong>, que é o <em>Instalador Imaginário do Vi</em>. As telas seguintes fazem parte desse instalador, que instala e configura o editor de textos Vi em sua máquina.</p>

<p><strong>Instruções Importantes:</strong></p>

<ul>
  <li>Não veja essa lista com pressa.</li>
  <li>Analise com atenção os detalhes de cada tela, acompanhe na linha de comando as opções e parâmetros utilizados, redigite (ou copie e cole) os comandos na sua Shell e veja os exemplos "ao vivo".</li>
  <li>Experimente mudar alguns parâmetros e ver o que acontece, explore as possibilidades.</li>
  <li>Não se preocupe agora em "como" o Dialog funciona, mas sim com "o quê" ele faz.</li>
  <li>Descubra-o, experimente-o, é de graça!</li>
  <li>Faça desse momento uma apresentação, imersão e aprendizado, para entrar no mundo do Dialog.</li>
</ul>

<blockquote>
  <strong>IMPORTANTE:</strong> Releia e siga as instruções acima!
</blockquote>

<p>Ao final dessa viagem, se você seguir as instruções acima, com certeza você terá uma boa idéia dos poderes do Dialog, do quanto ele pode lhe ser útil e de onde você poderá aplicá-lo.</p>

<p>Não se assuste se de repente você ficar cheio de idéias e ter vontade de fazer uns 5 programas diferentes agora mesmo, <em>isso é normal! :)</em>. O Dialog tem esse poder de sedução por sua simplicidade e flexibilidade.</p>

<blockquote>
  <strong>Nota:</strong> A quebra dos comandos em várias linhas é apenas estética, não obrigatória.
</blockquote>

<h3 id="calendar">3.1. Calendar</h3>

<pre>
dialog                       \
   --title 'Escolha a data'  \
   --calendar ''             \
   0 0                       \
   31 12 1999
</pre>

<img class="center" src="calendar.png" alt="">

<h3 id="checklist">3.2. Checklist</h3>

<pre>
dialog                                      \
   --title 'Seleção dos Componentes'        \
   --checklist 'O que você quer instalar?'  \
   0 0 0                                    \
   syntax  'Arquivos de sintaxe'      on    \
   mouse   'Suporte a mouse'          off   \
   color   'Suporte a cores'          on    \
   beep    'Driver avançado de som'   off
</pre>

<img class="center" src="checklist.png" alt="">

<h3 id="fselect">3.3. Fselect</h3>

<pre>
dialog                              \
   --title 'Escolha onde instalar'  \
   --fselect /usr/share/vim/        \
   0 0
</pre>

<img class="center" src="fselect.png" alt="">

<h3 id="gauge">3.4. Gauge</h3>

<pre>
dialog                                     \
   --title 'Instalação dos Pacotes'        \
   --gauge '\nInstalando Vim-6.0a.tgz...'  \
   8 40 60
</pre>

<img class="center" src="gauge.png" alt="">

<h3 id="infobox">3.5. Infobox</h3>

<pre>
dialog                                         \
   --title 'Aguarde'                           \
   --infobox '\nFinalizando em 5 segundos...'  \
   0 0
</pre>

<img class="center" src="infobox.png" alt="">

<h3 id="inputbox">3.6. Inputbox, Passwordbox</h3>

<pre>
dialog                                           \
   --title 'Confirmação'                         \
   --passwordbox 'Por favor, confirme a senha:'  \
   0 0
</pre>

<img class="center" src="passwordbox.png" alt="">

<h3 id="menu">3.7. Menu</h3>

<pre>
dialog                                       \
   --title 'Perfil'                          \
   --menu 'Escolha o perfil da instalação:'  \
   0 0 0                                     \
   mínima       'Instala o mínimo'           \
   completa     'Instala tudo'               \
   customizada  'Você escolhe'
</pre>

<img class="center" src="menu.png" alt="">

<h3 id="msgbox">3.8. Msgbox</h3>

<pre>
dialog                                            \
   --title 'Parabéns'                             \
   --msgbox 'Instalação finalizada com sucesso.'  \
   6 40
</pre>

<img class="center" src="msgbox.png" alt="">

<h3 id="radiolist">3.9. Radiolist</h3>

<pre>
dialog                                           \
   --title 'Pergunta'                            \
   --radiolist 'Há quanto tempo você usa o Vi?'  \
   0 0 0                                         \
   iniciante  'até 1 ano'      on                \
   experiente 'mais de 1 ano'  off               \
   guru       'mais de 3 anos' off
</pre>

<img class="center" src="radiolist.png" alt="">

<h3 id="tailbox">3.10. Tailbox, Tailboxbg</h3>

<pre>
tail -f /var/log/messages &gt; out &amp;

dialog                                         \
   --title 'Monitorando Mensagens do Sistema'  \
   --tailbox out                               \
   0 0
</pre>

<img class="center" src="tailbox.png" alt="">

<h3 id="textbox">3.11. Textbox</h3>

<pre>
dialog                                        \
   --title 'Visualizando Arquivo'             \
   --textbox /usr/share/vim/vim60/indent.vim  \
   0 0
</pre>

<img class="center" src="textbox.png" alt="">

<h3 id="timebox">3.12. Timebox</h3>

<pre>
dialog                                        \
   --title 'Ajuste o Relógio'                 \
   --timebox '\nDICA: Use as setas e o TAB.'  \
   0 0                                        \
   23 59 30
</pre>

<img class="center" src="timebox.png" alt="">

<h3 id="yesno">3.13. Yesno</h3>

<pre>
dialog                                          \
   --title 'AVISO'                              \
   --yesno '\nO Vi foi instalado e configurado.
            Você quer executá-lo agora?\n\n'    \
   0 0
</pre>

<img class="center" src="yesno.png" alt="">

<p>Agora que você já ficou horas copiando e colando os exemplos, ou redigitando os comandos, já está apto a conhecer o <a href="dialog-tour.sh">dialog-tour</a>, um script pronto para ser executado que mostra todas as caixas para você :)</p>

<h2 id="funcionamento">4. Como o Dialog funciona</h2>

<p>E então, já está cheio de idéias?</p>

<dl>
  <dt><strong>Sim</strong></dt>
  <dd>Ótimo! Então vamos continuar o aprendizado e conhecer os detalhes do Dialog para poder usá-lo em scripts.</dd>
  <dt><strong>Não</strong></dt>
  <dd>
    Você seguiu as instruções do tópico anterior?
    <dl>
      <dt><strong>Sim</strong></dt>
      <dd>Então invista mais um tempo na shell, executando os exemplos, modificando-os, avaliando as possibilidades do Dialog. Veja as figuras, imagine onde você poderia utilizar aquelas telinhas, nos seus programas atuais, em programas novos que você poderia fazer... Depois volte aqui e continuamos a leitura.</dd>
      <dt><strong>Não</strong></dt>
      <dd>É uma pena. Nesse ponto do documento você já seria um conhecedor do Dialog. Considere voltar ao tópico anterior e tentar de novo.</dd>
    </dl>
  </dd>
</dl>

<p>O Dialog é relativamente simples de usar, mas como ele age um pouco "diferente" dos outros programas do sistema, pode assustar e parecer confuso numa primeira tentativa.</p>

<p>Como agora você já sabe "o quê" o Dialog pode fazer, adiante veremos em detalhes como construir e obter dados das caixas, e aprenderemos algumas características do Dialog como:</p>

<ul>
  <li>A linha de comando é longa, cheia de opções</li>
  <li>Ele redimensiona o texto e a caixa automaticamente</li>
  <li>Usa código de retorno para botões Sim/Não, Ok/Cancel</li>
  <li>Usa a saída de erro (STDERR) para textos e itens escolhidos</li>
</ul>

<h3 id="parametros">4.1. Entendendo os parâmetros obrigatórios da linha de comando</h3>

<p>No Dialog, é obrigatório passar o texto e o tamanho da caixa, sempre. Com isso, a cada chamada do programa, devem haver pelo menos 4 opções na linha de comando.</p>

<p>O formato genérico de chamada é:</p>

<pre>
dialog --tipo-da-caixa '&lt;texto&gt;' &lt;altura&gt; &lt;largura&gt;
</pre>

<dl>
  <dt><em>texto</em></dt>
  <dd>O texto é a palavra ou frase que aparece no início da caixa, logo após a primeira linha (borda superior). Passe uma string vazia '' caso não deseje texto. Caso o texto seja maior que o tamanho da janela, ele será ajustado automaticamente, quebrando a linha. Para colocar as quebras de linhas manualmente, insira o padrão '\n' (barra-ene) onde desejar as quebras. Exemplo: '<em>Primeira linha.\nSegunda.</em>'</dd>
  <dt><em>altura</em></dt>
  <dd>A altura é o número de linhas que serão utilizadas para desenhar a caixa, inclusive a primeira e a última que fazem as bordas superior e inferior. Se informado o número zero, o Dialog ajusta automaticamente a altura da caixa para caber o conteúdo.</dd>
  <dt><em>largura</em></dt>
  <dd>A largura é o número de colunas que serão utilizadas para desenhar a caixa, inclusive a primeira e a última que fazem as bordas esquerda e direita. Se informado o número zero, o Dialog ajusta automaticamente a largura da caixa para caber o conteúdo.</dd>
</dl>

<p>Na prática, é melhor deixar que o Dialog quebre o texto e ajuste o tamanho das caixas automaticamente. Então nos exemplos desse documento não haverá quebras de linha manuais (\n) e os tamanhos serão sempre especificados como "0 0" (zero zero).</p>

<blockquote>
  <strong>Nota:</strong> Em caixas como o menu, onde também é preciso passar todos os itens pela linha de comando, há mais parâmetros obrigatórios além dos já citados. Eles serão abordados adiante, no momento oportuno.
</blockquote>

<h3 id="simnao">4.2. Como reconhecer respostas SIM ou NÃO</h3>

<p>A forma mais básica de se comunicar com o usuário é fazendo perguntas que ele possa responder com Sim ou Não. É possível fazer um configurador, ou até mesmo um programinha simples com essas respostas. Já foi visto como fazer uma telinha desse tipo:</p>

<pre>
dialog --yesno 'sim ou não?' 0 0
</pre>

<p>Mas, e dentro de um script, como saber qual foi a resposta do usuário? Qual foi o botão que ele apertou?</p>

<p>O Dialog utiliza o código de retorno ("<em>Return Code</em>") para informar qual foi o botão apertado. Como sabemos, o shell guarda esse código dentro da variável <code>$?</code>.</p>

<p>Então que tal descobrirmos a solução do problema testando? Execute o seguinte comando duas vezes, e note qual o código de retorno que aparece quando se escolhe "Yes" e quando se escolhe "No".</p>

<pre>
dialog --yesno 'sim ou não?' 0 0 ; echo Retorno: $?
</pre>

<p class="figure">
  <img src="simnao.png">
</p>

<p>Fácil! Zero para Sim, um para não.</p>

<p>Se lembrarmos que todos os comandos UNIX/Linux retornam zero em sucesso e qualquer coisa diferente de zero (geralmente 1) quando ocorre algum erro, fica fácil memorizar. O zero é sempre positivo, beleza, sem erro, <strong>SIM</strong>. O um é problema, erro, <strong>NÃO</strong>.</p>

<blockquote>
  <strong>Memorizando:</strong> SIM=0, NÃO=1
</blockquote>

<p>Agora que sabemos isso, fica fácil lidar com as respostas do usuário. Basta usar o <code>if</code> para testar o valor do <code>$?</code>. Um exemplo bem simples:</p>

<pre>
dialog --yesno 'Quer ver as horas?' 0 0

if [ $? = 0 ]; then
        echo "Agora são: $( date )"
else
        echo 'Ok, não vou mostrar as horas.'
fi
</pre>

<p>Caso a mensagem do <code>else</code> não seja necessária, podemos usar o operador <code>&amp;&amp;</code> (AND) e deixar o comando bem mais simples:</p>

<pre>
dialog --yesno 'Quer ver as horas?' 0 0 &amp;&amp; echo "Agora são: $(date)"
</pre>

<p class="figure">
  <img src="horas.png">
</p>

<p>Usando o Dialog fica fácil definir variáveis de estado ("<em>flags</em>") ou opções antes da execução de um programa! Por exemplo, um programa simples para listar arquivos do diretório atual:</p>

<pre>
#!/bin/sh
# lsj.sh -- o script do "ls joiado"
# Este script faz parte do http://aurelio.net/shell/dialog

# Zerando as opções
cor= ; ocultos= ; subdir= ; detalhes=

# Obtendo as configurações que o usuário deseja
dialog --yesno 'Usar cores?'               0 0 &amp;&amp; cor='--color=yes'
dialog --yesno 'Mostrar arquivos ocultos?' 0 0 &amp;&amp;  ocultos='-a'
dialog --yesno 'Incluir sub-diretórios?'   0 0 &amp;&amp;   subdir='-R'
dialog --yesno 'Mostrar visão detalhada?'  0 0 &amp;&amp; detalhes='-l'

# Mostrando os arquivos
ls $cor $ocultos $subdir $detalhes
</pre>

<p><a href="lsj.sh">Baixar este script</a></p>

<h3 id="textodigitado">4.3. Como obter o texto que o usuário digitou</h3>

<p>A caixa <code>Inputbox</code> serve para pedir que o usuário digite algo. A sua prima é a <code>Passwordbox</code>, que tem funcionamento idêntico, apenas não mostra na tela o que o usuário digita (útil para senhas).</p>

<p>Por exemplo, se quisermos que o usuário digite seu nome. Primeiro construímos a telinha:</p>

<pre>
dialog --inputbox 'Digite seu nome:' 0 0
</pre>

<p>Tudo bem, o usuário digita seu nome, aperta OK e poft! O nome é repetido na tela e volta o prompt. Como guardar o que foi digitado numa variável, para usar depois?</p>

<p>O funcionamento padrão do Dialog é: após o usuário digitar seu nome e apertar o OK, esse texto é mandado para a saída de erro (<code>STDERR</code>). Temos três maneiras de "pescar" esse texto:</p>

<ol>
  <li>Redirecionar a STDERR para um arquivo e ler o conteúdo desse arquivo</li>
  <li>Redirecionar a STDERR para a STDOUT</li>
  <li>Usar a opção --stdout do Dialog</li>
</ol>

<p>Veremos então essas três táticas. A primeira consiste em redirecionar para um arquivo, e é com certeza a maneira mais incômoda por precisar de um arquivo temporário, mas também é mais portável e que funciona em qualquer Shell. Como todos sabemos como fazer um redirecionamento, vamos direto ao exemplo:</p>

<pre>
dialog --inputbox 'Digite seu nome:' 0 0  2&gt;/tmp/nome.txt

nome=$( cat /tmp/nome.txt )
echo "O seu nome é: $nome"
</pre>

<p class="figure">
  <img src="nome.png">
</p>

<p>Guardamos na variável 'nome' o conteúdo do arquivo temporário. A notação <code>$(comando)</code> para subshell será a utilizada em todo o documento. A similar usando crases também funciona, mas é facilmente confundida com aspas simples, então será evitada.</p>

<p>A segunda maneira é mais limpa por não precisar criar o arquivo temporário. Basta utilizar o operador <code>2&gt;&amp;1</code> para redirecionar a saída de erro para a saída padrão. Com o texto desejado na saída padrão, podemos definir a variável 'nome' diretamente:</p>

<pre>
nome=$( dialog --inputbox 'Digite seu nome:' 0 0  2&gt;&amp;1 )
echo "O seu nome é: $nome"
</pre>

<p>Mas acaba sendo incômodo ter que ficar redirecionando a saída de erro sempre, a cada chamada do Dialog. A terceira maneira de obter o texto leva isso em conta e usa uma opção do próprio programa para redirecionar o texto para a saída padrão, a <code>--stdout</code>:</p>

<pre>
nome=$( dialog --stdout --inputbox 'Digite seu nome:' 0 0 )
echo "O seu nome é: $nome"
</pre>

<p>Das três formas apresentadas, esta é a mais limpa. Assim, nos exemplos seguintes, a opção <code>--stdout</code> será sempre utilizada.</p>

<p>Ah! A caixa Inputbox também aceita um último parâmetro opcional que é o texto inicial já preechido no campo. Exemplo:</p>

<pre>
dialog --stdout --inputbox 'Digite seu nome:' 0 0 "seu nome aqui"
</pre>

<h3 id="itemescolhido">4.4. Como obter o item único escolhido de um Menu ou Radiolist</h3>

<p>Já sabemos como fazer telas tipo Sim/Não. Mas e se precisarmos ampliar o leque de respostas possíveis do usuário, onde também poderíamos ter "Talvez" ou "Não sei" como respostas válidas? Ou ainda, se precisarmos que o usuário escolha um item de um menu para saber qual das opções ele quer executar?</p>

<p>Nesse caso o Sim/Não é insuficiente, e precisamos usar a caixa do tipo Menu, onde podemos especificar vários itens diferentes e o usuário escolhe um (e apenas um). Para começar, vamos fazer um exemplo bem bobo:</p>

<pre>
user=$( dialog --stdout --menu 'Bobice:' 0 0 0   1 um 2 dois 3 três )
echo Você escolheu o número $user
</pre>

<p class="figure">
  <img src="bobice1.png">
</p>

<p>A primeira grande diferença a se notar é que a linha de comando do Dialog ficou gigante, cheia de parâmetros! Vamos destrinchá-la.</p>

<p>Até o 'Bobice:', nenhuma novidade. Mas seguido dele estão três zeros onde geralmente só tinha dois! Não, isso não é erro de digitação :)</p>

<p>Os dois primeiros zeros continuam sendo a altura e largura da caixa, isso nunca muda. Já o terceiro zero é uma propriedade especial do Menu, que indica quantos itens serão "visíveis" de uma vez na caixa. Veja a diferença de trocar este zero por um:</p>

<pre>
dialog --stdout --menu 'Bobice:' 0 0 1   1 um 2 dois 3 três
</pre>

<p class="figure">
  <img src="bobice2.png">
</p>

<p>Agora apenas um item é visível por vez, diminuindo o tamanho da caixa. Isso pode ser útil quando o Menu tem muitas opções, mas para que a caixa fique num tamanho aceitável, mostra-se apenas parte delas por vez e deve-se fazer uma "rolagem" para ver o resto.</p>

<p>Logo após esta definição do número de itens, colocamos enfileirados todos os itens do Menu, no formato "<em>&lt;item&gt; &lt;descrição&gt;</em>". Em nosso exemplo são três itens numéricos.</p>

<p>Este é o formato genérico da linha de comando da caixa Menu:</p>

<pre>
dialog --menu '&lt;texto&gt;' 0 0 &lt;núm-itens&gt; &lt;item1&gt; &lt;desc1&gt; ... &lt;itemN&gt; &lt;descN&gt;
</pre>

<dl>
  <dt><em>núm-itens</em></dt>
  <dd>O número máximo de itens do menu que serão mostrados na caixa. Os demais ficarão ocultos e podem ser acessados rolando a lista com as setas do teclado. Caso especificado como zero, o Dialog mostra todos os itens, ou ajusta automaticamente o número ideal para que a caixa caiba na tela.</dd>
  <dt><em>item</em></dt>
  <dd>O item deve ser um nome único, diferente para cada item. O item é o texto retornado pelo Dialog ao script, quando o usuário escolhe uma opção.</dd>
  <dt><em>descrição</em></dt>
  <dd>A descrição é um texto explicativo que serve para detalhar do que se trata o item. A descrição pode ser omitida passando a string vazia ''. Exemplo: <code>dialog --menu 'texto' 0 0 0 item1 '' item2 '' item3 ''</code></dd>
</dl>

<p>Agora que sabemos compor esse monstro que é a linha de comando de um Menu, vamos fazer mais um exemplo, com nomes ao invés de números nos itens do menu:</p>

<pre>
cor=$( dialog --stdout --menu 'As cores:' 0 0 0 amarelo 'a cor do sol' verde 'a cor da grama' azul 'a cor do céu' )
echo Você escolheu a cor $cor
</pre>

<p class="figure">
  <img src="cor1.png">
</p>

<p>Não é tão difícil hein? A dica para não se confundir é enxergar a linha de comando como várias pequena partes, identificando e isolando cada uma delas:</p>

<pre>
dialog
        --stdout                     # usa o STDOUT
        --menu  'As cores:'          # texto do menu
        0 0 0                        # altura, largura e núm. itens
        amarelo 'a cor do sol'       # item 1
        verde   'a cor da grama'     # item 2
        azul    'a cor do céu'       # item 3
</pre>

<p>Por isso que geralmente os comandos Dialog são colocados em várias linhas, para fazer essa separação em partes e facilitar o entendimento. Para tal, basta "escapar" o final de cada linha do comando (exceto a última) com uma barra \. Veja como fica o exemplo anterior quebrado em várias linhas:</p>

<pre>
cor=$( dialog \
        --stdout \
        --menu 'As cores:' \
        0 0 0 \
        amarelo 'a cor do sol' \
        verde 'a cor da grama' \
        azul 'a cor do céu' )
echo Você escolheu a cor $cor
</pre>

<p>Bem melhor não? Adicionalmente, pode-se alinhar os escapes e os itens para facilitar ainda mais a leitura:</p>

<pre>
cor=$( dialog                    \
        --stdout                 \
        --menu 'As cores:'       \
        0 0 0                    \
        amarelo 'a cor do sol'   \
        verde   'a cor da grama' \
        azul    'a cor do céu'   )
echo Você escolheu a cor $cor
</pre>

<p>Esta será a notação utilizada nos exemplos, por ser a mais didática.</p>

<p><strong>CUIDADO!</strong> Não coloque comentários ou espaços em branco após a barra de escape, ela deve ser o último caractere da linha.</p>

<pre>
dialog --stdout      \  # Esse comando é inválido. Estes
       --yesno texto \  # comentários não podem estar aqui.
       0 0
</pre>

<p>O primo próximo do Menu é o Radiolist. A única diferença entre os dois, é que no Radiolist é possível definir qual será o item que já iniciará selecionado. Para isso, cada item é composto por três parâmetros: <em>nome, descrição, status</em>. O status deve ser <code>ON</code> ou <code>OFF</code>, para informar se o item está "ligado" (marcado) ou não.</p>

<p>Como na Radiolist o usuário só pode escolher um único item, cuidado na hora de compor o comando, pois apenas um item pode ter o status ON, todos os outros devem ser OFF. Caso precise de uma lista de múltipla escolha, veja o Checklist no tópico seguinte.</p>

<p>Usando o exemplo anterior, podemos iniciar a caixa com a cor "verde" já selecionada:</p>

<pre>
dialog --radiolist 'As cores:' 0 0 0 \
        amarelo 'a cor do sol'   OFF \
        verde   'a cor da grama' ON  \
        azul    'a cor do céu'   OFF
</pre>

<p class="figure">
  <img src="cor2.png">
</p>

<p>Ah! A outra diferença do Radiolist para o Menu é que ele usa os parênteses <code>(X)</code> para marcar o item.</p>

<h3 id="itensescolhidos">4.5. Como obter os itens múltiplos escolhidos de um Checklist</h3>

<p>A caixa Checklist é idêntica a Radiolist já vista, a única diferença é o usuário poder escolher mais de um item; é uma caixa de múltipla escolha.</p>

<p>Primeiro, vamos fazer um menu com opções para o usuário escolher:</p>

<pre>
estilos=$( dialog --stdout \
        --checklist 'Você gosta de:' 0 0 0 \
        rock  '' ON  \
        samba '' OFF \
        metal '' ON  \
        jazz  '' OFF \
        pop   '' ON  \
        mpb   '' OFF )
echo "Você escolheu: $estilos"
</pre>

<p class="figure">
  <img src="rock1.png">
</p>

<p>A sintaxe é a mesma da Radiolist, e compomos uma lista onde os itens não têm descrição (usando as aspas vazias ''). A diferença agora é que temos mais de um item selecionado.</p>

<p>Note que o Dialog retorna todos na mesma linha, com cada item escolhido entre aspas duplas. Esse retorno em apenas uma linha requer conhecimento em Sed, Awk ou outro editor programável para se identificar e extrair corretamente os itens escolhidos.</p>

<p>Como isso dificulta o uso do Dialog, ele possui uma opção de linha de comando chamada <code>--separate-output</code>, que ao invés de retornar tudo em uma linha, retorna os itens selecionados um por linha, e sem as aspas. Dessa maneira fica bem mais fácil varrer e descobrir os itens escolhidos com o 'while':</p>

<pre>
estilos=$( dialog --stdout \
        --separate-output \
        --checklist 'Você gosta de:' 0 0 0 \
        rock  '' ON  \
        samba '' OFF \
        metal '' ON  \
        jazz  '' OFF \
        pop   '' ON  \
        mpb   '' OFF )

echo "$estilos" | while read LINHA
do
        echo "--- $LINHA"
done
</pre>

<p class="figure">
  <img src="rock2.png">
</p>

<h3 id="botaocancelar">4.6. E se o usuário apertar o botão CANCELAR?</h3>

<p>Você faz as telinhas, apronta os menus, deixa tudo certinho para funcionar redondo. Mas, no meio do programa, o usuário desiste de tudo e aperta o botão CANCELAR. Como detectar isso?</p>

<p>Assim como acontece com os botões Yes/No, o Dialog usa os Códigos de Retorno para informar se o usuário pressionou o OK ou o CANCELAR.</p>

<blockquote>
  OK=0, CANCELAR=1
</blockquote>

<p>Então sempre após cada telinha do dialog, coloque o seguinte teste para saber se o CANCELAR foi apertado:</p>

<pre>
[ $? -eq 1 ] &amp;&amp; echo 'Botão CANCELAR apertado'
</pre>

<p>Dependendo de como funciona seu programa, você pode fazer o aperto do CANCELAR retornar à tela anterior, ao menu principal, ou ainda ser mais drástico e abandonar o programa. Tudo depende do tipo de navegação que você quer usar.</p>

<p>Além de apertar o botão CANCELAR, o usuário também pode apertar a tecla Esc do teclado. Veja o tópico seguinte.</p>

<h3 id="teclaesc">4.7. E se o usuário apertar a tecla ESC?</h3>

<p>Em qualquer tela do Dialog, apertar a tecla Esc gera o código de retorno 255, e abandona a caixa. Então além de tratar do botão OK (retorno zero) e do CANCELAR (retorno 1), também é preciso cuidar da tecla Esc.</p>

<p>Dependendo do tipo de sua aplicação, a tecla Esc pode gerar o mesmo procedimento que apertar o botão CANCELAR geraria. Ou ainda, você pode ter dois procedimentos diferentes, um para cada evento. Tudo depende do tipo de navegação que seu programa utiliza, algumas sugestões:</p>

<dl>
  <dt><strong>Navegação amarrada a um Menu Principal</strong></dt>
  <dd>
    <ul>
      <li>Se apertar CANCELAR no Menu Principal, sai do programa</li>
      <li>Se apertar CANCELAR numa tela secundária, volta ao Menu Principal</li>
      <li>Se apertar ESC em qualquer tela, sai do programa</li>
    </ul>
  </dd>
  <dt><strong>Navegação tipo Ida e Volta</strong></dt>
  <dd>
    <ul>
      <li>Se apertar CANCELAR volta à tela anterior</li>
      <li>Se apertar ESC sai do programa</li>
    </ul>
  </dd>
</dl>

<p>Veja exemplos completos desses tipos de navegação e do tratamento dos eventos no tópico seguinte.</p>

<p>Caso queira mapear o Esc para o mesmo funcionamento do CANCELAR, você pode fazer um teste mais genérico como, "se não for o OK":</p>

<pre>
[ $? -ne 0 ] &amp;&amp; echo 'Esc ou CANCELAR apertado'
</pre>

<p>Claro, se estiver usando botão de HELP, ele também será mapeado para o CANCELAR, então cuidado.</p>

<h3 id="botaohelp">4.8. E se o usuário apertar o botão HELP?</h3>

<p>O botão de ajuda (HELP) foi adicionado no dialog-0.9b, para usá-lo basta adicionar a opção <code>--help-button</code>. O seu código de retorno quando apertado é dois. Vamos lá, memorizando novamente:</p>

<blockquote>
  OK=0, CANCELAR=1, HELP=2
</blockquote>

<p>O teste primário para saber se ele foi apertado é:</p>

<pre>
[ $? -eq 2 ] &amp;&amp; echo 'Botão HELP apertado'
</pre>

<p>Para mostrar o texto de ajuda para o usuário, basta usar uma caixa Msgbox se for curto, ou uma Textbox se for algo mais extenso. Depois é só voltar para a caixa anterior.</p>

<h3 id="tratarbotoes">4.9. Como tratar todos os botões e teclas de uma vez?</h3>

<pre>
case $? in
          0) echo O usuário apertou o botão OK (ou o Yes) ;;
          1) echo O usuário apertou o botão CANCELAR (ou o No) ;;
          2) echo O usuário apertou o botão HELP ;;
        255) echo O usuário apertou a tecla ESC ;;
          *) echo Retorno desconhecido;;
esac
</pre>

<h2 id="mergulhando">5. Mergulhando de cabeça no Dialog</h2>

<h3 id="menuloop">5.1. Exemplo de menu amarrado (em loop)</h3>

<p class="figure">
  <img src="tia.png">
</p>

<pre>
#!/bin/bash
# tia.sh - o script da tia que precisa usar o computador
# Este script faz parte do http://aurelio.net/shell/dialog
#
# Exemplo de como amarrar o script num menu principal usando
# o 'while'. O 'case' é usado para identificar qual foi a ação
# escolhida. Após cada ação, ele sempre retorna ao menu
# principal. Só sai do script caso escolha a última opção,
# aperte CANCELAR ou ESC.
#
# Útil para usar como login shell de pessoas inexperientes ou
# fazer utilitários de ações restritas e definidas.
#
# FLUXOGRAMA
#                      INÍCIO                    FIM
#                   +-----------+            +----------+
#          +------&gt; |    menu   |--Esc-----&gt; |  sai do  |
#          |        | principal |--Cancel--&gt; | programa |
#          |        +-----Ok----+       +--&gt; +----------+
#          |              |             |
#          +--&lt;--1 2 3-4--+--Zero---&gt;---+
#

# Loop que mostra o menu principal
while : ; do

    # Mostra o menu na tela, com as ações disponíveis
    resposta=$(
      dialog --stdout               \
             --title 'Menu da Tia'  \
             --menu 'Oi Tia, escolha o quê você quer fazer:' \
            0 0 0                   \
            1 'Navegar na Internet' \
            2 'Escrever uma carta'  \
            3 'Jogar paciência'     \
            4 'Perder tempo'        \
            0 'Sair'                )

    # Ela apertou CANCELAR ou ESC, então vamos sair...
    [ $? -ne 0 ] &amp;&amp; break

    # De acordo com a opção escolhida, dispara programas
    case "$resposta" in
         1) /usr/bin/mozilla 'http://google.com.br' ;;
         2) /bin/mcedit /tmp/carta.txt ;;
         3) /usr/games/solitaire ;;
         4) /usr/X11R6/bin/xsnow ; /usr/X11R6/bin/xeyes ;;
         0) break ;;
    esac

done

# Mensagem final :)
echo 'Tchau Tia!'
</pre>

<p><a href="tia.sh">Baixar este script</a></p>

<h3 id="encadeado">5.2. Exemplo de telas encadeadas (navegação sem volta)</h3>

<p class="figure">
  <img src="encadeado.png">
</p>

<pre>
#!/bin/sh
# encadeado.sh - o script que chega até o final
# Este script faz parte do http://aurelio.net/shell/dialog
#
# Exemplo de como encadear telas usando o operador &amp;&amp; (AND).
# Caso o usuário desista em qualquer tela (apertando CANCELAR
# ou ESC), o script executa o primeiro comando após a cadeia
# de &amp;&amp;.
#
# Útil para fazer programas ou brincadeiras onde só há um
# caminho certo a seguir para chegar ao final.
#
# FLUXOGRAMA
#             INÍCIO
#            +-------+
#            | tela1 |--Cancel/Esc---&gt;---+
#            +--Ok---+                   |
#            | tela2 |--Cancel/Esc---&gt;---+     +----------+
#            +--Ok---+                   |---&gt; | desistiu |
#            | tela3 |--Cancel/Esc---&gt;---+     +----------+
#            +--Ok---+                   |
#            | tela4 |--Cancel/Esc---&gt;---+
#            +--Ok---+
#            | final |
#            +-------+
#               FIM
#

# Função rápida para chamar a caixa YesNo
simnao(){
    dialog --yesno "$*" 0 0
}

# Aqui começa o encadeamento de telas com o &amp;&amp;.
# Somente apertando o botão OK vai para a próxima tela.
# Há um 'exit' no final, que sai do script caso o usuário
# tenha chegado até o fim da cadeia.
simnao 'Quer continuar?'                    &amp;&amp;
simnao 'Estamos na segunda tela. Continua?' &amp;&amp;
simnao 'Terceira. Continua continuando?'    &amp;&amp;
simnao 'Penúltima tela! E agora, continua?' &amp;&amp;
echo 'Você chegou até o final!'             &amp;&amp; exit

# Este trecho já não faz mais parte do encadeamento, e só
# será alcançado caso o usuário tenha apertado CANCELAR/Esc.
echo Você desistiu antes de chegar no final...
</pre>

<p><a href="encadeado.sh">Baixar este script</a></p>

<h3 id="idaevolta">5.3. Exemplo de telas com navegação completa (ida e volta)</h3>

<table>
  <tr>
    <td><img class="center" src="nav1.png" alt=""></td>
    <td>→</td>
    <td><img class="center" src="nav2.png" alt=""></td>
    <td>→</td>
  </tr>
  <tr>
    <td><img class="center" src="nav3.png" alt=""></td>
    <td>→</td>
    <td><img class="center" src="nav4.png" alt=""></td>
    <td>→</td>
  </tr>
  <tr>
    <td><img class="center" src="nav5.png" alt=""></td>
    <td>→</td>
    <td><img class="center" src="nav6.png" alt=""></td>
    <td>fim</td>
  </tr>
</table>

<pre>
#!/bin/bash
# navegando.sh - o script que vai e volta
# Este script faz parte do http://aurelio.net/shell/dialog
#
# Exemplo de como ligar todas as telas do programa entre si,
# guardando informações de ida e volta. O botão CANCELAR faz
# voltar para a tela anterior e o OK faz ir à próxima. Para
# sair do programa a qualquer momento basta apertar o ESC.
#
# Útil para fazer programas interativos, de contexto, ou que
# se pode voltar para corrigir informações.
#
# FLUXOGRAMA
#                    INÍCIO
#                 +-----------+
#                 | primeira  |--Esc---&gt;---+
#      .--------&gt; +----Ok-----+            |
#      `--Cancel--|   nome    |--Esc---&gt;---+
#      .--------&gt; +----Ok-----+            |     +----------+
#      `--Cancel--|   idade   |--Esc---&gt;---+---&gt; |  Sai do  |
#      .--------&gt; +----Ok-----+            |     | Programa |
#      `--Cancel--| est.civil |--Esc---&gt;---+     +----------+
#      .--------&gt; +----Ok-----+            |
#      `--Cancel--|   gostos  |--Esc---&gt;---+
#                 +----Ok-----+
#                 |   final   |
#                 +-----------+
#                      FIM
#

proxima=primeira

# loop principal
while : ; do

    # Aqui é identificada qual tela deve ser mostrada.
    # Em cada tela são definidas as variáveis 'anterior'
    # e 'proxima' # que definem os rumos da navegação.
    case "$proxima" in
        primeira)
            proxima=nome
            dialog --backtitle 'Pegador de Dados' \
                --msgbox 'Bem-vindo ao pegador de dados!' 0 0
            ;;
        nome)
            anterior=primeira
            proxima=idade
            nome=$(dialog --stdout \
                --backtitle 'Pegador de Dados' \
                --inputbox 'Seu nome:' 0 0)
            ;;
        idade)
            anterior=nome
            proxima=casado
            idade=$(dialog --stdout \
                --backtitle 'Pegador de Dados'   \
                --menu 'Qual a sua idade?' 0 0 0 \
                'menos de 15 anos'   '' \
                'entre 15 e 25 anos' '' \
                'entre 25 e 40 anos' '' \
                'mais de 40 anos'    '' )
            ;;
        casado)
            anterior=idade
            proxima=gostos
            casado=$(dialog --stdout \
                --backtitle 'Pegador de Dados'    \
                --radiolist 'Estado civil:' 0 0 0 \
                'solteiro' 'livre leve solto' ON  \
                'noivo'    'quase amarrado'   OFF \
                'casado'   'já era'           OFF \
                'viúvo'    'livre de novo'    OFF )
            ;;
        gostos)
            anterior=casado
            proxima=final
            gostos=$(dialog --stdout \
                --separate-output                      \
                --backtitle 'Pegador de Dados'         \
                --checklist 'Do que você gosta?' 0 0 0 \
                'jogar futebol'      '' off \
                'pescar'             '' off \
                'ir ao shopping'     '' off \
                'andar de bicicleta' '' off \
                'ficar na internet'  '' off \
                'dormir'             '' off )
            ;;
        final)
            dialog \
                --cr-wrap \
                --sleep 5 \
                --backtitle 'Pegador de Dados'   \
                --title 'Obrigado por responder' \
                --infobox "
                Os dados informados foram
                Nome  : $nome
                Idade : $idade
                Casado: $casado
                Gostos: \n$gostos
                " 14 40
            break
            ;;
        *)
            echo "Janela desconhecida '$proxima'."
            echo Abortando programa...
            exit
    esac

    # Aqui é feito o tratamento genérico de Código de Retorno
    # de todas as telas. Volta para a tela anterior se for
    # CANCELAR, sai do programa se for ESC.
    retorno=$?
    [ $retorno -eq 1   ] &amp;&amp; proxima=$anterior   # cancelar
    [ $retorno -eq 255 ] &amp;&amp; break               # Esc

done
</pre>

<p><a href="navegando.sh">Baixar este script</a></p>

<h3 id="confirmacao">5.4. Exemplo de pedido de confirmação (uma caixa sobre outra)</h3>

<p class="figure">
  <img src="duas.png">
</p>

<pre>
#!/bin/sh
# duas.sh - o script que pede confirmação
# Este script faz parte do http://aurelio.net/shell/dialog
#
# Exemplo de como fazer caixas sobrepostas, onde a nova caixa
# aparece sobre a primeira, típico de avisos como:
#
#    "Você tem certeza?"
#
# O fonte do próprio script é usado como a "licença", mas na
# vida real, basta trocar o $0 por um arquivo como o COPYING
#

dialog --title 'LICENÇA do Software' --textbox $0 16 65 \
       --and-widget \
       --yesno '\nVocê aceita os Termos da Licença?' 8 30 
</pre>

<p><a href="duas.sh">Baixar este script</a></p>

<h3 id="posicionar">5.5. Exemplo de posicionamento de caixas (não centralizado)</h3>

<p class="figure">
  <img src="posicao.png">
</p>

<pre>
#!/bin/sh
# posicao.sh - o script que posiciona a janela
# Este script faz parte do http://aurelio.net/shell/dialog
#
# Com a opção --begin, é possível definir qual vai ser o
# posicionamento da caixa na tela. A sintaxe é "--begin X Y",
# onde X e Y são as coordenadas de LINHA e COLUNA onde vai
# estar o canto superior esquerdo da caixa.
#
# Por exemplo, para grudar a caixa no canto esquerdo da tela,
# a partir da linha 5:

dialog --begin 5 0 \
       --msgbox 'Eu estou grudada no canto esquerdo' 10 30
</pre>

<p><a href="posicao.sh">Baixar este script</a></p>

<h3 id="multicaixas">5.6. Exemplo de várias caixas na mesma tela (multicaixas!)</h3>

<p class="figure">
  <img src="multi1.png">
</p>

<p class="figure">
  <img src="multi2.png">
</p>

<pre>
#!/bin/sh
# multi.sh - o script que desenha várias janelas
# Este script faz parte do http://aurelio.net/shell/dialog
#
# Exemplo de como desenhar várias caixas numa mesma tela,
# usando a opção --and-widget para juntar as caixas e o opção
# --begin para pocisionar as janelas.
#
#
#    Brincando de Posicionar Caixas
#    ------------------------------
#
# Usando a opção --begin, definimos o posicionamento da
# caixa. Usando a opção --and-widget, colocamos mais de uma
# caixa na tela. Usando essas duas opções juntas, podemos
# mostrar várias janelas inteiras na tela sem sobreposição!
#
# Por exemplo, que tal dividir a tela em 4 partes iguais e
# colocar uma janela em cada uma dessas partes? Isso pode ser
# útil para mostrar ao usuário o "histórico" das telas que
# ele já passou.
#
# O cálculo de posicionamento é simples. O tamanho padrão de
# tela do console é 80 colunas por 25 linhas. Para facilitar,
# consideremos o tamanho da tela de 80x24, para usarmos
# números pares somente. A última linha da tela não será
# usada.
#
# Se queremos 4 caixas, basta dividir tanto as colunas quanto
# as linhas por 2 e teremos quatro "pedaços" iguais na tela:
#
#        80/2 = 40
#        25/2 = 12
# 
# Com isso, sabemos que todas as janelas terão 12 linhas e 40
# colunas. Esses números também definem as coordenadas de
# posicionameto:
#
#                               0        40        80 colunas
#      Coordenadas:            0+---------+---------+
#        ( x, y )               | 0,0     | 0,40    |     
#          0, 0                 |       #1|       #2|
#          0,40               12+---------+---------+
#         12, 0                 | 12,0    | 12,40   |
#         12,40                 |       #3|       #4|
#                             24+---------+---------+
#                               linhas
#     
#
# Obs.: O --no-shadow é usado para que a caixa não tenha
#       sombra.
#

dialog --no-shadow \
       --begin   0  0 --msgbox 'Janela #1 -- (0,0)  ' 12 40 --and-widget \
       --begin   0 40 --msgbox 'Janela #2 -- (0,40) ' 12 40 --and-widget \
       --begin  12  0 --msgbox 'Janela #3 -- (12,0) ' 12 40 --and-widget \
       --begin  12 40 --msgbox 'Janela #4 -- (12,40)' 12 40


# Fracionando mais as coordenadas, dá pra fazer muitas firulas.
# 100% inútil, mas é legal de ver &amp;:)
#
dialog --no-shadow \
       --begin  0  0 --infobox DIALOG 6 20 --and-widget \
       --begin  0 40 --infobox DIALOG 6 20 --and-widget \
       --begin  6 20 --infobox DIALOG 6 20 --and-widget \
       --begin  6 60 --infobox DIALOG 6 20 --and-widget \
       --begin 12  0 --infobox DIALOG 6 20 --and-widget \
       --begin 12 40 --infobox DIALOG 6 20 --and-widget \
       --begin 18 20 --infobox DIALOG 6 20 --and-widget \
       --sleep 6 --begin 18 60 --infobox DIALOG 6 20
</pre>

<p><a href="multi.sh">Baixar este script</a></p>

<h3 id="menudinamico">5.7. Exemplo de menu com itens dinâmicos (definidos em execução)</h3>

<p class="figure">
  <img src="users.png">
</p>

<pre>
#!/bin/bash
# users.sh - Compõe menus com os usuários do sistema
# Este script faz parte do http://aurelio.net/shell/dialog
#
# Exemplo de como construir menus dinâmicos, onde os itens
# são a saída de um comando. Nos exemplos, serão obtidos os
# dados do arquivo /etc/passwd, como login, UID e nome.
#
# São três exemplos:
#
#   1) O mais simples. O comando retorna um login por linha.
#      Como cada entrada do menu precisa de dois campos, no
#      segundo campo foi colocado uma letra 'o', para ficar
#      esteticamente bonito. Poderia ser um ponto '.' ou
#      qualquer outro caractere ou texto. Outra alternativa
#      é repetir o login. Isso pode ser feito trocando o
#      comando sed para 's/.*/&amp; &amp;/'.
#
#   2) Aqui, o próprio comando já retorna dois campos por
#      linha, no formato login:uid. Depois foi usado o tr
#      pra trocar os : por espaços, separando os dados e
#      deixando pronto para usar no menu.
#
#   3) Similar ao segundo, só que ao invés de pegar o 3o
#      campo do passwd (uid), foi pego o 5o, que é o nome
#      completo do usuário. O grande problema aqui é que
#      como o nome tem espaços em branco, cada palavra é
#      encarada como um parâmetro e bagunça o menu. A
#      solução é colocar o nome entre \"aspas escapadas\"
#      e usar o 'eval' para executar o comando.
#
#      Para ficar bem claro o que está acontecendo, troque
#      o 'eval' por um 'echo' para ver qual o comando final
#      que está sendo executado. Aqui está ele:
#
# dialog --menu "Dois campos por linha, 2o item com espaços"
# 0 0 0 root "root" bin "bin" daemon "daemon" adm "adm"
# lp "lp" sync "sync" shutdown "shutdown" halt "halt"
# mail "mail" news "news" uucp "uucp" operator "operator"
# games "games" gopher "gopher" ftp "FTP User" ...
#
# 12 Agosto 2004 - Aurelio Marinho Jargas

ARQUIVO=/etc/passwd

dialog --menu 'Lista normal de um campo por linha' \
        0 0 10 $(cat $ARQUIVO | cut -d: -f1 | sed 's/$/ o/')

dialog --menu 'Dois campos por linha, sem espaços nos itens' \
        0 0 10 $(cat $ARQUIVO | cut -d: -f1,3 | tr : ' ')

eval \
dialog --menu \"Dois campos por linha, 2o item com espaços\" \
        0 40 10 $(
                IFS=:
                while read login senha uid gid nome resto; do
                        echo $login \"$nome\"
                done &lt; $ARQUIVO
        )
</pre>

<p><a href="users.sh">Baixar este script</a></p>

<h3 id="copiagauge">5.8. Exemplo de cópia de arquivos com barra de progresso (Gauge)</h3>

<table>
  <tr>
    <td><img class="center" src="copydir1.png" alt=""></td>
  </tr>
  <tr>
    <td><img class="center" src="copydir2.png" alt=""></td>
  </tr>
</table>

<pre>
#!/bin/bash
# copydir.sh - Copia o diretório mostrando uma barra de progresso
# Este script faz parte do http://aurelio.net/shell/dialog
#
# Uso:  copydir.sh  &lt;dir-origem&gt;  &lt;dir-destino&gt;
#
# Exemplo de uso da caixa de barra de progresso (gauge), que é
# diferente e meio complicada de usar. Ela espera receber a
# porcentagem da barra via STDIN, sendo um número de 0 a 100.
#
# O Gauge só mostra na tela a porcentagem que você informar,
# ele não tem inteligência, então todo o controle sobre o
# processo deve ser feito manualmente pelo programador.
#
# O procedimento se resume em duas ações:
#
#   1) Saber como quantificar o TOTAL, para conhecer o 100%.
#      No caso de uma cópia de arquivos, o TOTAL é o tamanho
#      total de todos os arquivos a serem copiados.
#
#   2) Saber como descobrir de tempos em tempos o STATUS
#      corrente do procedimento, enquanto ele está sendo
#      executado, para poder calcular o quanto ainda falta
#      para o final (100%). No caso de uma cópia de arquivos,
#      o STATUS é a quantidade de arquivos que já foi copiada,
#      ou o espaço em disco ocupado por eles.
#
# Tendo os dois dados não, uma simples regrinha de três lhe dá
# a porcentagem atual do andamento: STATUS*100/TOTAL.
#
# 12 Agosto 2004 - Aurelio Marinho Jargas

#................................................................

TITLE='Copiando...'
MSG='Copiando o diretório $ORIGEM para $DESTINO'
INTERVALO=1       # intervalo de atualização da barra (segundos)
PORCENTO=0        # porcentagem inicial da barra

#................................................................

ORIGEM="${1%/}"
DESTINO="${2%/}"

die()    { echo "Erro: $*" ; exit 1 ; }
sizeof() { du -s "$1" | cut -f1; }
running(){ ps $1 | grep $1 &gt;/dev/null; }

#................................................................

# tem somente dois parâmetros?
[ "$2" ] || die "Uso: $0 dir-origem dir-destino"

# a origem e o destino devem ser diretórios
[ -d "$ORIGEM"  ] || die "A origem '$ORIGEM' deve ser um diretório"
[ -d "$DESTINO" ] || die "O destino '$DESTINO' deve ser um diretório"

# mesmo dir?
[ "$ORIGEM" = "$DESTINO" ] &amp;&amp;
        die "A origem e o destino são o mesmo diretório"

# o diretório de destino está vazio?
DIR_DESTINO="$DESTINO/${ORIGEM##*/}"
[ -d "$DIR_DESTINO" ] &amp;&amp; [ $(sizeof $DIR_DESTINO) -gt 4 ] &amp;&amp;
        die "O dir de destino '$DIR_DESTINO' deveria estar vazio"

#................................................................

# expansão das variáveis da mensagem
MSG=$(eval echo $MSG)

# total a copiar (em bytes)
TOTAL=$(sizeof $ORIGEM)

# início da cópia, em segundo plano
cp -r $ORIGEM $DESTINO &amp;
CPPID=$!

# caso o usuário cancele, interrompe a cópia
trap "kill $CPPID" 2 15

#................................................................

# loop de checagem de status da cópia
(
        # enquanto o processo de cópia estiver rodando
        while running $CPPID; do
        
                # quanto já foi copiado?
                COPIADO=$(sizeof $DIR_DESTINO)
                
                # qual a porcentagem do total?
                PORCENTAGEM=$((COPIADO*100/TOTAL))
                
                # envia a porcentagem para o dialog
                echo $PORCENTAGEM
                
                # aguarda até a próxima checagem
                sleep $INTERVALO
        done    

        # cópia finalizada, mostra a porcentagem final
        echo 100
        
) | dialog --title "$TITLE" --gauge "$MSG" 8 40 0

#................................................................

echo OK - Diretório copiado
</pre>

<p><a href="copydir.sh">Baixar este script</a></p>

<h3 id="cores">5.9. Configurando as cores das caixas</h3>

<p>É possível configurar as cores de TODOS os componentes das caixas, como textos, borda, botões e fundo da tela. Dessa maneira pode-se personalizar os programas que usam o Dialog para a empresa ou indivíduo que o utilizará.</p>

<p>Para obter o arquivo padrão de configuração do Dialog, basta usar a opção <code>--create-rc</code>. Como o programa procura dentro de seu $HOME por um arquivo chamado <code>.dialogrc</code>, use este comando para começar a brincar de trocar as cores do Dialog:</p>

<pre>
dialog --create-rc $HOME/.dialogrc
</pre>

<p>Agora basta editar o arquivo <code>.dialogrc</code> recém-criado no seu $HOME e executar o Dialog para ver a diferença. As cores que ele reconhece são:</p>

<table>
  <tr>
    <th>Cor no Dialog</th>
    <th>Cor</th>
  </tr>
  <tr>
    <td>BLACK</td>
    <td>Preto</td>
  </tr>
  <tr>
    <td>RED</td>
    <td>Vermelho</td>
  </tr>
  <tr>
    <td>GREEN</td>
    <td>Verde</td>
  </tr>
  <tr>
    <td>YELLOW</td>
    <td>Amarelo</td>
  </tr>
  <tr>
    <td>BLUE</td>
    <td>Azul</td>
  </tr>
  <tr>
    <td>MAGENTA</td>
    <td>Rosa</td>
  </tr>
  <tr>
    <td>CYAN</td>
    <td>Ciano</td>
  </tr>
  <tr>
    <td>WHITE</td>
    <td>Branco</td>
  </tr>
</table>

<p>O formato das configurações de cores é:</p>

<pre>
nome_do_componente = (letra, fundo, letra brilhante?)
</pre>

<p>Onde para <em>letra</em> e <em>fundo</em> basta colocar os nomes das cores em inglês, e no terceiro parâmetro, coloque ON ou OFF para que as letras fiquem brilhantes ou não (claras ou escuras). Exemplo:</p>

<table>
  <tr>
    <td>(GREEN, BLACK, OFF)</td>
    <td>=</td>
    <td>fundo preto, letra verde escuro</td>
  </tr>
  <tr>
    <td>(GREEN, BLACK, ON)</td>
    <td>=</td>
    <td>fundo preto, letra verde claro</td>
  </tr>
</table>

<p>Depois de terminar de configurar as cores, você pode salvar tudo num arquivo separado, e fazer vários arquivos diferentes para vários "temas" ou configurações diferentes.</p>

<p>Para instruir o Dialog a utilizar um arquivo de configuração específico, e não o padrão <code>$HOME/.dialogrc</code>, basta definir a variável de ambiente <code>$DIALOGRC</code> com o nome arquivo a ser utilizado, por exemplo:</p>

<pre>
export DIALOGRC=$HOME/dialog/tema-verde.cfg
./navegando.sh
</pre>

<table>
  <tr>
    <td><img class="center" src="temaverde1.png" alt=""></td>
    <td><img class="center" src="temaverde2.png" alt=""></td>
  </tr>
</table>

<p>Como exemplo, este é o arquivo que configurou o Dialog para este tema tipo console verde:</p>

<pre>
# Tema "Verde" tipo console para o Dialog.
# Autor: Aurelio Marinho Jargas
#   Salvar este arquivo como $HOME/.dialogrc
#   ou definir a variável $DIALOGRC

# screen
use_shadow   = OFF
use_colors   = ON
screen_color = (GREEN,BLACK,ON)
# box
dialog_color = (BLACK,GREEN,OFF)
title_color  = (BLACK,GREEN,OFF)
border_color = (BLACK,GREEN,OFF)
# button
button_active_color         = (BLACK,GREEN,OFF)
button_inactive_color       = (BLACK,GREEN,OFF)
button_key_active_color     = (GREEN,BLACK,OFF)
button_key_inactive_color   = (BLACK,GREEN,OFF)
button_label_active_color   = (GREEN,BLACK,OFF)
button_label_inactive_color = (BLACK,GREEN,OFF)
# input
inputbox_color        = (GREEN,BLACK,ON)
inputbox_border_color = (GREEN,BLACK,ON)
# textbox
searchbox_color          = (GREEN,BLACK,ON)
searchbox_title_color    = (GREEN,BLACK,OFF)
searchbox_border_color   = (GREEN,BLACK,OFF)
position_indicator_color = (BLACK,GREEN,OFF)
# Menu box
menubox_color          = (GREEN,BLACK,OFF)
menubox_border_color   = (GREEN,BLACK,OFF)
# Menu window
item_color             = (GREEN,BLACK,OFF)
item_selected_color    = (BLACK,GREEN,OFF)
tag_color              = (GREEN,BLACK,OFF)
tag_selected_color     = (BLACK,GREEN,OFF)
tag_key_color          = (GREEN,BLACK,OFF)
tag_key_selected_color = (BLACK,GREEN,OFF)
check_color            = (GREEN,BLACK,OFF)
check_selected_color   = (BLACK,GREEN,OFF)
uarrow_color           = (GREEN,BLACK,ON)
darrow_color           = (GREEN,BLACK,ON)
# Menu item help
itemhelp_color         = (GREEN,BLACK,ON)
</pre>

<p><a href="tema-verde.cfg">Baixar este arquivo</a></p>

<h2 id="opcoes">6. APÊNDICE A: Lista das opções de linha de comando</h2>

<h3 id="opcoes-textos">6.1. Opções para definir os textos da caixa</h3>

<dl>
  <dt><code>--backtitle &lt;texto&gt;</code></dt>
  <dd>Especifica o título do topo da tela, que fica no plano de fundo, atrás da caixa (Veja exemplo do "Pegador de Dados").</dd>
  <dt><code>--title &lt;texto&gt;</code></dt>
  <dd>Define o título da caixa, colocado centralizado na borda superior.</dd>
  <dt><code>--cancel-label &lt;texto&gt;</code></dt>
  <dd>Especifica o texto para ser mostrado no botão "Cancel".</dd>
  <dt><code>--exit-label &lt;texto&gt;</code></dt>
  <dd>Especifica o texto para ser mostrado no botão "Exit".</dd>
  <dt><code>--help-label &lt;texto&gt;</code></dt>
  <dd>Especifica o texto para ser mostrado no botão "Help".</dd>
  <dt><code>--ok-label &lt;texto&gt;</code></dt>
  <dd>Especifica o texto para ser mostrado no botão "OK".</dd>
</dl>

<h3 id="opcoes-ajustes-textos">6.2. Opções para fazer ajustes no texto da caixa</h3>

<dl>
  <dt><code>--cr-wrap</code></dt>
  <dd>Mantém as quebras de linha originais do texto da caixa, para não precisar colocar os '\n'. Mas lembre-se que caso a linha fique muito grande, o Dialog a quebrará no meio para caber na caixa.</dd>
  <dt><code>--no-collapse</code></dt>
  <dd>Mantém o espaçamento original do texto, não retirando os TABs nem os espaços em branco consecutivos.</dd>
  <dt><code>--tab-correct</code></dt>
  <dd>Converte cada TAB para N espaços. O N é especificado na opção '--tab-len' ou o padrão 8 é assumido.</dd>
  <dt><code>--tab-len &lt;N&gt;</code></dt>
  <dd>Especifica o número de espaços que serão colocados no lugar de cada TAB, quando usar o opção '--tab-correct'.</dd>
  <dt><code>--trim</code></dt>
  <dd>Limpa o texto da caixa, apagando espaços em branco no início, espaços consecutivos e quebras de linha literais.</dd>
</dl>

<h3 id="opcoes-ajustes">6.3. Opções para fazer ajustes na caixa</h3>

<dl>
  <dt><code>--aspect &lt;taxa&gt;</code></dt>
  <dd>Taxa que ajusta o dimensionamento automático das caixas. É a relação largura / altura, sendo o padrão 9, que significa 9 colunas para cada linha.</dd>
  <dt><code>--begin &lt;y&gt; &lt;x&gt;</code></dt>
  <dd>Especifica a posição inicial da caixa, relativo ao canto superior esquerdo.</dd>
  <dt><code>--defaultno</code></dt>
  <dd>Faz o botão 'Não' ser o padrão da caixa YesNo.</dd>
  <dt><code>--default-item &lt;item&gt;</code></dt>
  <dd>Define qual vai ser o item pré-selecionado do Menu. Se não especificado, o primeiro item será o selecionado.</dd>
  <dt><code>--shadow</code></dt>
  <dd>Desenha a sombra da caixa. Opção já usada normalmente.</dd>
  <dt><code>--no-shadow</code></dt>
  <dd>Não desenha a sombra da caixa.</dd>
  <dt><code>--no-cancel</code> ou <code>--nocancel</code></dt>
  <dd>Não mostra o botão CANCELAR nas caixas Checklist, Inputbox e Menu. A tecla Esc continua valendo para sair da caixa.</dd>
  <dt><code>--item-help</code></dt>
  <dd>Usada nas caixas Checklist, Radiolist ou Menu, mostra uma linha de ajuda no rodapé da tela para o item selecionado. Esse texto é declarado se adicionando uma nova coluna no final da definição de cada item.</dd>
  <dt><code>--help-button</code></dt>
  <dd>Mostra um botão de "Help". Seu código de retorno é 2.</dd>
</dl>

<h3 id="opcoes-dados">6.4. Opções relativas aos dados informados pelo usuário</h3>

<dl>
  <dt><code>--separate-output</code></dt>
  <dd>Na caixa Checklist, retorna os itens selecionados, um por linha e sem aspas. Bom para scripts!</dd>
  <dt><code>--separate-widget &lt;separador&gt;</code></dt>
  <dd>Define o separador que será colocado entre os retornos de cada caixa. Útil quando se trabalha com múltiplas caixas. O separador padrão é o TAB.</dd>
  <dt><code>--stderr</code></dt>
  <dd>Retorna os dados na Saída de Erros (STDERR). Opção já usada normalmente.</dd>
  <dt><code>--stdout</code></dt>
  <dd>Retorna os dados na Saída Padrão (STDOUT) ao invés da STDERR.</dd>
  <dt><code>--max-input &lt;tamanho&gt;</code></dt>
  <dd>Tamanho máximo do texto que o usuário pode digitar nas caixas. O tamanho padrão é 2000 caracteres.</dd>
</dl>

<h3 id="opcoes-sozinhas">6.5. Opções que devem ser usadas sozinhas na linha de comando</h3>

<dl>
  <dt><code>--clear</code></dt>
  <dd>Restaura a tela caso o Dialog a tenha bagunçado.</dd>
  <dt><code>--create-rc &lt;arquivo&gt;</code></dt>
  <dd>Gera uma arquivo de configuração do Dialog.</dd>
  <dt><code>--help</code></dt>
  <dd>Mostra a ajuda do dialog, com as opções disponíveis.</dd>
  <dt><code>--print-maxsize</code></dt>
  <dd>Mostra o tamanho atual da tela na STDERR.</dd>
  <dt><code>--print-version</code></dt>
  <dd>Mostra a versão do Dialog na STDERR.</dd>
  <dt><code>--version</code></dt>
  <dd>O mesmo que '--print-version'.</dd>
</dl>

<h3 id="opcoes-outras">6.6. Outras opções</h3>

<dl>
  <dt><code>--ignore</code></dt>
  <dd>Ignora as opções inválidas. Serve para manter compatibilidade apenas.</dd>
  <dt><code>--size-err</code></dt>
  <dd>Opção antiga que não é mais usada.</dd>
  <dt><code>--beep</code></dt>
  <dd>Apita cada vez que a tela é desenhada.</dd>
  <dt><code>--beep-after</code></dt>
  <dd>Apita na saída com o Ctrl+C</dd>
  <dt><code>--sleep &lt;N&gt;</code></dt>
  <dd>Faz uma pausa de N segundos após processar a caixa. Útil para a Infobox.</dd>
  <dt><code>--timeout &lt;N&gt;</code></dt>
  <dd>Sai do programa com erro caso o usuário não faça nada em N segundos.</dd>
  <dt><code>--no-kill</code></dt>
  <dd>Coloca a caixa Tailboxbg em segundo plano (desabilitando seu SIGHUP) e mostra o ID de seu processo na STDERR.</dd>
  <dt><code>--print-size</code></dt>
  <dd>Mostra o tamanho de cada caixa na STDERR.</dd>
  <dt><code>--and-widget</code></dt>
  <dd>Junta uma ou mais caixas numa mesma tela (sem limpá-la).</dd>
</dl>

<h2 id="clones">7. APÊNDICE B: Os clones: Xdialog, Kdialog, gdialog, ...</h2>

<p>Todos os programas listados aqui são "clones" do Dialog, pois foram feitos para substituir o Dialog, ou dar uma nova roupagem a ele usando bibliotecas gráficas.</p>

<p>Os clones usam a mesma sintaxe, as mesmas opções de linha de comando, e todos têm o mesmo propósito: ser como o Dialog, só que diferente :)</p>

<p>Além de fazer tudo o que o Dialog faz, alguns clones evoluíram e adicionaram novos tipos de caixa e funcionalidades novas.</p>

<blockquote>
  <strong>Dica:</strong> É possível fazer um Shell Script que escolha usar o Dialog texto ou o gráfico, dependendo se o usuário está no X ou não. Basta checar a existência da variável <code>$DISPLAY</code>, que só é definida quando o X está sendo executado.
</blockquote>

<h3 id="whiptail">7.1. Whiptail</h3>

<p class="figure">
  <img src="whiptail.png">
</p>

<p>Clone modo texto, que usa a biblioteca <code>newt</code> ao invés da <code>ncurses</code>.</p>

<p>Ele foi escrito pela Red Hat Software para ser utilizado na instalação modo texto do Red Hat Linux. Como é baseado numa versão antiga do Dialog, não tem suporte às caixas novas como calendar, fselect e tailbox.</p>

<ul>
  <li>
    <a href="http://packages.debian.org/stable/base/whiptail.html">Pacote Debian</a>
  </li>
  <li>
    <a href="http://linux.math.tifr.res.in/manuals/man/whiptail.html">Página de Manual</a>
  </li>
</ul>

<h3 id="xdialog">7.2. Xdialog</h3>

<p class="figure">
  <img src="xdialog.png">
</p>

<p>É o Dialog para a interface gráfica, que usa a biblioteca Gtk+.</p>

<p>É de longe o Dialog mais "turbinado", pois também tem o botão Help que chama a tela de Ajuda da caixa e introduziu vários tipos novos de caixa como: treeview, buildlist, editbox, rangebox, logbox, spin boxes, combobox, colorsel, fontsel.</p>

<p>É também o clone mais bem documentado, possuindo uma excelente homepage e documentação online. Em especial <a href="http://thgodef.nerim.net/xdialog/doc/box.html">esta parte</a> da documentação mostra figuras (screenshots) de todas as caixas novas implementadas.</p>

<ul>
  <li>
    <a href="http://xdialog.dyns.net">Site oficial</a>
  </li>
  <li>
    <a href="http://thgodef.nerim.net/xdialog/doc/>Documentação Online</a>
  </li>
</ul>

<h3 id="kdialog">7.3. Kdialog</h3>

<p class="figure">
  <img src="kdialog.png">
</p>

<p>O Dialog do time do KDE, que usa a biblioteca Qt.</p>

<p>Como os grandes "ambientes gráficos" gostam de reescrever todos os aplicativos existentes, com o Dialog não podia ser diferente. O Kdialog é o Dialog integrado com o ambiente KDE.</p>

<ul>
  <li>
    <a href="ftp://ftp.kde.org/pub/kde/unstable/apps/utils/">FTP</a>
  </li>
  <li>
    <a href="http://developer.kde.org/documentation/tutorials/kdialog/t1.html">Tutorial bem completo em inglês</a>
  </li>
</ul>

<h3 id="gdialog">7.4. gdialog</h3>

<p class="figure">
  <img src="gdialog.png">
</p>

<p>O antigo Dialog do time do Gnome, que usa a biblioteca Gtk.</p>

<p>Aparentemente o Zenity (ver adiante) é o novo "Dialog oficial" do Gnome e o gdialog vai ser aposentado. O interessante desse clone é que carrega o nome do ilustre Alan Cox como desenvolvedor participante.</p>

<h3 id="zenity">7.5. Zenity</h3>

<p class="figure">
  <img src="zenity.png">
</p>

<p>O Dialog do time do Gnome, que usa a biblioteca Gtk.</p>

<p>Foi projetado para ser mais limpo e bem escrito do que o gdialog, porém se tornou <strong>incompatível</strong> com o dialog, pois usa opções diferentes na linha de comando (mais Zen e simples, segundo os autores). Há um script que garante a compatibilidade com o gdialog.</p>

<ul>
  <li>
    <a href="http://freshmeat.net/projects/zenity">Página no FreshMeat</a>
  </li>
  <li>
    <a href="http://ftp.gnome.org/pub/GNOME/sources/zenity/">FTP</a>
  </li>
  <li>
    <a href="http://cvs.gnome.org/bonsai/rview.cgi?cvsroot=/cvs/gnome&amp;dir=zenity">CVS</a>
  </li>
  <li>
    <a href="http://www.gustavoroberto.blog.br/2007/09/21/algumas-coisas-sobre-zenity-parte-i/">Artigo em português, com exemplos</a>
  </li>
</ul>

<h3 id="udpm">7.6. Udpm</h3>

<p>O "User Dialog Perl Module" não é um clone do Dialog, mas uma interface Perl para trabalhar de maneira padronizada com os seguintes "sabores": dialog, cdialog, whiptail, gdialog e Kdialog.</p>

<ul>
  <li>
    <a href="http://udpm.sourceforge.net/">Site oficial</a>
  </li>
</ul>

<h3 id="pythondialog">7.7. pythondialog</h3>

<p>Módulo em Python para usar trabalhar de maneira padronizada com os seguintes "sabores": dialog, whiptail e Xdialog.</p>

<ul>
  <li>
    <a href="http://people.via.ecp.fr/~flo/2002/pythondialog/pythondialog.html">Site oficial</a>
  </li>
</ul>

<h2 id="sobre">8. Sobre este documento</h2>

<p>A primeira versão levou 5 dias para ser feita, totalizando 27 horas de escrita. Além da escrita do conteúdo, nesse tempo também foram feitas outras tarefas dignas de uma primeira versão:</p>

<ul>
  <li>(Re)aprendizado do Dialog e leitura de sua documentação,</li>
  <li>Definição do formato do documento (ordem dos tópicos, layout),</li>
  <li>Definição do aspecto do documento (fazer o arquivo de estilo CSS),</li>
  <li>Produção de todas as imagens (testes, screenshot e tratamento).</li>
</ul>

<p>Este documento foi feito do zero, utilizando 100% Linux e Softwares Livres.</p>

<dl>
  <dt><em>Testes</em></dt>
  <dd>
    <ul>
      <li>Conectiva Linux 8 como Sistema Operacional</li>
      <li>Bash 2.04 como Shell</li>
      <li>Dialog versão 0.9a</li>
    </ul>
  </dd>
  <dt><em>Texto</em></dt>
  <dd>
    <ul>
      <li>
        <a href="http://www.vim.org">Vim</a> para escrever os textos
      </li>
      <li>
        <a href="http://txt2tags.sf.net/pt/">Txt2tags</a> para converter o texto fonte para HTML
      </li>
    </ul>
  </dd>
  <dt><em>Imagens</em></dt>
  <dd>
    <ul>
      <li>Xterm para executar o Dialog no modo gráfico (xterm +sb -b 0)</li>
      <li>xwd (do XFree86) para fazer o dump da janela do Xterm (xwd &gt; arquivo.xwd)</li>
      <li>ImageMagick para converter de .xwd para .png (convert arquivo.xwd arquivo.png)</li>
    </ul>
  </dd>
</dl>

<p>Atualmente, os testes são feitos com o dialog versão 0.9b. As novidades em relação à versão 0.9a são o botão de Help e as opções novas de linha de comando, registradas no Changelog da versão 5 deste documento.</p>

<h3 id="download">8.1. Disponibilidade (download)</h3>

<p>Este documento está disponível para leitura e download no formato HTML neste endereço:</p>

<p><a href="http://aurelio.net/shell/dialog">http://aurelio.net/shell/dialog</a></p>

<p>Para fazer o download do documento, de todas as suas figuras e scripts de exemplo, use os seguintes comandos:</p>

<pre>
mkdir dialog
cd dialog
wget -m -L http://aurelio.net/shell/dialog/
</pre>

<h3 id="changelog">8.2. Histórico de versões (Changelog)</h3>

<dl>
  <dt><strong>versão 1 — 25 de junho de 2003</strong></dt>
  <dd>
    <ul>
      <li>Versão inicial lançada.</li>
    </ul>
  </dd>
  <dt><strong>versão 2 — 29 de junho de 2003</strong></dt>
  <dd>
    <ul>
      <li>Adicionado sub-seção "Changelog" (esta aqui!)</li>
      <li>Adicionada seção "Breve Histórico do Dialog"</li>
      <li>Adicionadas informações resumidas de download e instalação</li>
      <li>Adicionado "Apêndice B" com informações sobre os clones do Dialog (<em>Obrigado Eri Ramos Bastos pela dica</em>)</li>
    </ul>
  </dd>
  <dt><strong>versão 3 — 05 de julho de 2003</strong></dt>
  <dd>
    <ul>
      <li>Adicionado tópico sobre licença/copyright (<em>Obrigado Marcelo Toledo pela dica</em>)</li>
      <li>Adicionado tópico sobre download do documento</li>
      <li>Reorganização de tópicos, melhoria da aparência (CSS)</li>
    </ul>
  </dd>
  <dt><strong>versão 4 — 27 de agosto de 2003</strong></dt>
  <dd>
    <ul>
      <li>Novo endereço oficial: http://aurelio.net/shell/dialog</li>
      <li>Comando de download arrumado (wget)</li>
      <li>Os scripts de exemplo foram reformatados</li>
      <li>Incluídos os scripts: dialog-tour, posicao, duas e multi</li>
      <li>Adicionada a opção --and-widget no Apêndice A</li>
      <li>Corrijidos eros de Protuguês :) (<em>Obrigado Marcelo Toledo por apontá-los</em>)</li>
    </ul>
  </dd>
  <dt><strong>versão 5 — 13 de agosto de 2004</strong></dt>
  <dd>
    <ul>
      <li>Adicionados nomes a cada título do documento (#âncoras), para ficarem mais descritivos os links diretos para seções específicas</li>
      <li>Incluído exemplo funcional de Gauge: copydir</li>
      <li>Incluído exemplo funcional de Menu Dinâmico: users</li>
      <li>Adicionado tópico sobre o botão HELP</li>
      <li>Adicionada menção ao valor inicial do texto da Inputbox</li>
      <li>Opções do Apêndice A reorganizadas por categorias</li>
      <li>Adicionados screenshots dos clones: whiptail, Xdialog, Kdialog, gdialog e zenity</li>
      <li>Adicionado link para tutorial do Kdialog</li>
      <li>Adicionadas informações sobre o módulo em Python do dialog</li>
      <li>Adicionadas no Apêndice A as opções novas de linha de comando da versão 0.9b do dialog: cancel-label, exit-label, help-label, ok-label, no-collapse, help-button, max-input e timeout</li>
    </ul>
  </dd>
  <dt><strong>versão 6 — junho de 2009</strong></dt>
  <dd>
    <ul>
      <li>Corrigido o ano da versão 5: s/2003/2004/ (<em>Obrigado Tiago F Bianchini por apontá-lo</em>)</li>
      <li>Títulos com iniciais maiúsculas (e não todas as palavras)</li>
      <li>Documento e exemplos convertidos para UTF-8</li>
      <li>Melhorias na formatação (tema novo)</li>
      <li>Resumido o Prefácio, que estava "acadêmico" demais</li>
    </ul>
  </dd>
</dl>

<h3 id="licenca">8.3. Licença / Copyright</h3>

<p>Este documento pode ser copiado, distribuído e divulgado livremente, parcial ou na íntegra, desde que não alterado seu conteúdo e citado o nome do autor:</p>

<blockquote>
  Aurelio Marinho Jargas
</blockquote>

<p>Se você encontrar erros, quiser adicionar conteúdo ou tiver qualquer alteração em mente, <strong>contate o autor</strong> <em>&lt;verde (a) aurelio net&gt;</em> para que o documento original seja editado e toda a comunidade possa usufruir de suas melhorias.</p>

<p>Em vez de colocar uma cópia deste documento em seu site, faça um link para a versão original em <a href="http://aurelio.net/shell/dialog">http://aurelio.net/shell/dialog</a>, para que seus usuários possam ler sempre a versão mais atualizada.</p>

<p>O plágio (dizer que foi você quem escreveu) e a utilização desse documento para fins comerciais (sites, livros e apostilas não-livres) são abominados e serão tomadas as atitudes cabíveis para coibi-los.</p>

<h3 id="maisinfo">8.4. Onde obter mais informações</h3>

<p>Uma pesquisa no <a href="http://www.google.com.br/search?q=dialog+tutorial">Google</a> mostra que a Internet está deficiente em documentação para o Dialog. O mais relevante é um artigo introdutório em inglês no <a href="http://www.linuxjournal.com/article.php?sid=2807">Linux Journal</a>.</p>

<p>Junto com o programa Dialog, tem alguma documentação em inglês. Tem a sua <a href="http://www.cl.cam.ac.uk/cgi-bin/manpage?1+dialog">página de manual</a> ("man page") que numa linguagem direta e sucinta traz detalhes sobre o seu funcionamento. Há também um diretório chamado "samples", onde tem scripts funcionais de exemplo de todos os tipos de caixa.</p>

<p>Na <a href="http://dickey.his.com/dialog/">página do Thomas Dickey</a>, o mantenedor atual do Dialog, há poucas informações, porém lá está o link para os fontes do programa.</p>

<p>Em português, a melhor fonte de informações é utilizar a <a href="http://br.groups.yahoo.com/group/shell-script/">lista shell-script</a> para obter ajuda e compartilhar experiências com outros usuários do Dialog.</p>

<p>O endereço oficial deste documento é</p>

<p><a href="http://aurelio.net/shell/dialog/">http://aurelio.net/shell/dialog/</a></p>

<p>Fim.</p>
